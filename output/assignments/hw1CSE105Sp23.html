<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE105Sp23" />
  <title>HW1 : Regular Expressions and Finite Automata</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW1 : Regular Expressions and Finite Automata</h1>
<p class="author">CSE105Sp23</p>
<p class="date">Due: April 11th at 5pm (no penalty late submission until
8am next morning), via Gradescope</p>
</header>
<p><span><strong>In this assignment,</strong></span></p>
<p>You will practice reading and applying the definitions of alphabets,
strings, languages, Kleene star, and regular expressions. You will use
regular expressions and relate them to languages and finite automata.
You will use precise notation to formally define the state diagram of
finite automata, and you will use clear English to describe computations
of finite automata informally.</p>
<p><span><strong>Resources</strong></span>: To review the topics for
this assignment, see the class material from Week 1. We will post
frequently asked questions and our answers to them in a pinned Piazza
post.</p>
<p><span><strong>Reading and extra practice problems</strong></span>:
Sipser Section 0, 1.3, 1.1. Chapter 1 exercises 1.1, 1.2, 1.3, 1.18,
1.23.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw1CSE105Sp23”.</p>
<p><span><strong>Assigned questions</strong></span></p>
<ol>
<li><p><strong>Functions over sets of strings</strong> (17
points):<br />
For this question, fix the alphabets <span class="math inline">\(\Sigma
= \{0,1\}\)</span> and <span class="math inline">\(\Gamma =
\{0,1,2\}\)</span>.</p>
<p>Whenever <span class="math inline">\(K\)</span> is a set of strings
over <span class="math inline">\(\Gamma\)</span> and <span
class="math inline">\(L\)</span> is a set of strings over <span
class="math inline">\(\Sigma\)</span>, we can use the following rules to
define associated sets of strings: <span
class="math display">\[\begin{aligned}
    \textsc{Substring}(K) &amp;:= \{ w \in \Gamma^* \mid \text{there
exist } a,b \in \Gamma^* \text{ such that } awb \in K\} \\
    \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every
    pair of successive $2$s in $w$ is a string in $L$}\}\\
    &amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in
\Sigma^* \text{ if } 2v2 \in \textsc{Substring}(\{w\})  \text{, then } v
\in L\}
    
\end{aligned}\]</span> <em>Note:</em> Formally, <span
class="math inline">\(\textsc{Substring}\)</span> and <span
class="math inline">\(\textsc{Rep}\)</span> are functions whose domains
and codomains are specified as <span
class="math display">\[\textsc{Substring}: \mathcal{P}(\Gamma^*) \to
\mathcal{P}(\Gamma^*)\]</span> and <span
class="math display">\[\textsc{Rep}: \mathcal{P}(\Sigma^*) \to
\mathcal{P}(\Gamma^*)\]</span> In other words, <span
class="math inline">\(\textsc{Substring}\)</span> maps sets of strings
with characters <span class="math inline">\(\{0,1,2\}\)</span> to
associated sets of strings with characters <span
class="math inline">\(\{0,1,2\}\)</span>; and <span
class="math inline">\(\textsc{Rep}\)</span> maps sets of strings with
characters in <span class="math inline">\(\{0,1\}\)</span> to associated
sets of strings with characters in <span
class="math inline">\(\{0,1,2\}\)</span>.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
Consider <span class="math inline">\(w = 0120\)</span> (which is a
string in <span class="math inline">\(\Gamma^*\)</span>). List every
element of the set <span
class="math inline">\(\textsc{Substring}(\{w\})\)</span>. In other
words, fill in the blank <span
class="math display">\[\textsc{Substring}(\{w\}) = \{
\underline{\phantom{\hspace{3in}}} \}\]</span> Briefly justify your
answer by referring back to the relevant definitions.</p>
<p><span><em>Not graded, but good to think about: Why do we need the
curly braces—“<span class="math inline">\(\{\)</span>” and “<span
class="math inline">\(\}\)</span>”—around <span
class="math inline">\(w\)</span> for the input to <span
class="math inline">\(\textsc{Substring}\)</span>?</em></span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Specify an example
language <span class="math inline">\(A\)</span> over <span
class="math inline">\(\Gamma\)</span> such that <span
class="math inline">\(A \neq \Gamma^*\)</span> and yet <span
class="math inline">\(\textsc{Substring}(A) = \Gamma^*\)</span>, or
explain why there is no such example. A complete solution will include
either (1) a precise and clear description of your example language
<span class="math inline">\(A\)</span> and a precise and clear
description of the result of computing <span
class="math inline">\(\textsc{Substring}(A)\)</span> using relevant
definitions to justify this description and to justify the set equality
with <span class="math inline">\(\Gamma^*\)</span>, or (2) a
sufficiently general and correct argument why there is no such example,
referring back to the relevant definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
Define the language <span class="math inline">\(B\)</span> to be the
language over <span class="math inline">\(\Sigma\)</span> described by
the regular expression <span class="math display">\[\Sigma^* 1
\Sigma^*\]</span> In plain English, we might explain that <span
class="math inline">\(B\)</span> is the set of all strings of <span
class="math inline">\(0\)</span>s and <span
class="math inline">\(1\)</span>s that contain a <span
class="math inline">\(1\)</span>. Give a plain English explanation for
the set of strings <span
class="math inline">\(\textsc{Rep}(B)\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Prove/disprove:
For every finite language <span class="math inline">\(L\)</span> over
<span class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\textsc{Rep}(L)\)</span> is also a finite set of
strings. A complete answer will either give a general argument starting
with an arbitrary finite language and proving that the result of
applying <span class="math inline">\(\textsc{Rep}\)</span> is also
finite, or will give a counterexample (which is a specific example of a
finite language <span class="math inline">\(L\)</span> for which
applying <span class="math inline">\(\textsc{Rep}\)</span> gives an
infinite language, with justification referring back to the relevant
definitions).</p>
<p><span><em>Note: A finite language is a set of finitely many strings.
This includes the possibility that <span
class="math inline">\(L\)</span> is the empty set!</em></span></p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Write a template
for a regular expression that describes <span
class="math inline">\(\textsc{Rep}(L)\)</span> when <span
class="math inline">\(L\)</span> is described by a regular expression
<span class="math inline">\(R\)</span>. You may use union,
concatenation, Kleene star, and <span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\Gamma\)</span>, and <span
class="math inline">\(R\)</span>. (We’re using the shorthand for regular
expressions describing alphabets from page 64.)</p></li>
</ol></li>
<li><p><strong>Deciphering regular expressions</strong> (22
points):<br />
For this question, let’s fix the regular expression over the alphabet
<span class="math inline">\(\{0,1\}\)</span> <span
class="math display">\[R = 0^* (1 \cup 10)^*\]</span></p>
<p>For each choice of strings of length <span
class="math inline">\(3\)</span>, <span class="math inline">\(a, b, c
\in \{0,1\}^3\)</span> we can define the regular expression: <span
class="math display">\[X_{a,b,c} = 0 (a \cup b \cup c)^*\]</span></p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) Give a plain
English explanation for the language described by the regular expression
<span class="math inline">\(R\)</span>. This continues a theme from
Problem 1—before trying to prove formal statements about a specific
regular expression, it’s often good to try to translate it into a form
that is more easy to reason about. Typically speaking, the shorter and
more concise your plain English description is, the more useful it will
be in reasoning about the language.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Suppose <span
class="math inline">\(a = 000\)</span>, <span
class="math inline">\(b=001\)</span>, <span
class="math inline">\(c=011\)</span> so <span
class="math display">\[X_{a,b,c} = 0 ( 000 \cup 001 \cup 011)^*\]</span>
Show that <span class="math inline">\(L(R) \not\subseteq
L(X_{a,b,c})\)</span> by giving some string in <span
class="math inline">\(L(R)\)</span> which is not in <span
class="math inline">\(L(X_{a,b,c})\)</span>, and justifying this choice
referring back to relevant definitions.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) More generally,
prove that <span class="math display">\[L(R) \not\subseteq
L(X_{a,b,c})\]</span> for <em>all</em> possible strings <span
class="math inline">\(a, b, c \in \{0,1\}^3\)</span>. Hint: What are the
possible lengths of strings in <span class="math inline">\(L(R)\)</span>
(and why does this help)?</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Give a specific
example of three distinct strings <span class="math inline">\(a, b, c
\in \{0,1,2\}^3\)</span> such that <span
class="math display">\[L(X_{a,b,c}) \subseteq L(R)\]</span> Briefly
justify your answer by explaining how an arbitrary element of <span
class="math inline">\(L(X_{a,b,c})\)</span> is guaranteed to be an
element of <span class="math inline">\(L(R)\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Give a specific
example of three distinct strings <span class="math inline">\(a, b, c
\in \{0,1,2\}^3\)</span> such that <span
class="math display">\[L(X_{a,b,c}) \not\subseteq L(R)\]</span> Briefly
justify your answer by giving a counterexample string that is in <span
class="math inline">\(L(X_{a,b,c})\)</span> and is not in <span
class="math inline">\(L(R)\)</span> (and explaining why using relevant
definitions).</p></li>
</ol></li>
<li><p><strong>The right transition function can make or break a
DFA</strong> (6 points):<br />
Consider the finite automaton <span class="math inline">\((Q, \Sigma,
\delta, q_0, F)\)</span> depicted below</p>
<div class="center">

</div>
<p>where <span class="math inline">\(Q = \{q_0, q_1, q_2\}\)</span>,
<span class="math inline">\(\Sigma = \{0,1\}\)</span>, and <span
class="math inline">\(F = \{q_0\}\)</span>.</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) Find and fix the
mistake in the following symbolic description of the transition function
<span class="math inline">\(\delta \colon Q \times \Sigma \to
Q\)</span>: for each <span class="math inline">\(j \in \{0,1\}\)</span>
<span class="math display">\[\delta(q_0, j) = q_j \hspace{2cm}
\delta(q_1, j) = q_{1-j} \hspace{2cm} \delta(q_2, j) =
q_{1+j}\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Keeping the same
set of states <span class="math inline">\(Q = \{q_0, q_1,
q_2\}\)</span>, alphabet <span class="math inline">\(\Sigma =
\{0,1\}\)</span>, starting state <span
class="math inline">\(q_0\)</span>, and set of accepting states <span
class="math inline">\(F = \{q_0\}\)</span>, change the transition
function <span class="math inline">\(\delta\)</span> so that the
resulting finite automaton recognizes the language described by the
regular expression <span class="math display">\[0^* \cup \Sigma^*
1000^*\]</span> Briefly justify why the resulting finite automaton works
by describing the role of each state with your new transition function
and relating it to a plain English description of the language described
by the regular expression.</p>
<p>Note: with regular expressions <span class="math inline">\(*\)</span>
binds more tightly than concatenation so <span
class="math inline">\(1000^* = (100)(0^*)\)</span>.</p></li>
</ol>
<p><span><em>(Challenge question, not graded) There is a beautiful plain
English description of the language recognized by the finite automaton
with the state diagram depicted at the start of Problem 3. What is
it?</em></span></p></li>
<li><p><strong>Being precise with terminology</strong> (5 points):<br />
For each of the following statements, determine if it is true, false, or
if the question doesn’t even make sense (because the statement isn’t
well formed or doesn’t use terms in ways consistent with definitions
from class).</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) The empty string
is in every language.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <span
class="math inline">\(\Sigma^*\)</span> is a language.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Every language is
a regular expression.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Alphabets are
infinite.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) There is a
(finite) number <span class="math inline">\(k \in \mathcal N\)</span>
such that every DFA has fewer than <span
class="math inline">\(k\)</span> states.</p></li>
</ol></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
