<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE105Sp23" />
  <title>HW2 : Regular Languages and Automata Constructions</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW2 : Regular Languages and Automata
Constructions</h1>
<p class="author">CSE105Sp23</p>
<p class="date">Due: April 18th at 5pm (no penalty late submission until
8am next morning), via Gradescope</p>
</header>
<p>You will practice designing multiple representations of regular
languages and working with general constructions of automata to
demonstrate the richness of the class of regular languages.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 1 and Week 2. We will
post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Sipser Section 1.1,
1.2, 1.3. Chapter 1 exercises 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11,
1.12, 1.14, 1.15, 1.16, 1.17, 1.19, 1.20, 1.21, 1.22.</p>
<p><em>Key Concepts:</em> Regular expressions, language described by a
regular expression, deterministic finite automata (DFAs), regular
languages, closure of the class of regular languages under certain
operations, nondeterministic finite automata (NFA).</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw2CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>It can be hard to give a good complement</strong> (15
points):<br />
For any language <span class="math inline">\(L \subseteq
\Sigma^*\)</span>, recall that we define its <em>complement</em> as
<span class="math display">\[\overline{L} := \Sigma^* - L = \{w \in
\Sigma^* \mid w \notin L\}\]</span> That is, the complement of <span
class="math inline">\(L\)</span> contains all and only those strings
which are not in <span class="math inline">\(L\)</span>. Our notation
for regular expressions does not include the complement symbol. However,
it turns out that the complement of a language described by a regular
expression is guaranteed to also be describable by a (different) regular
expression. For example, over the alphabet <span
class="math inline">\(\Sigma = \{0,1\}\)</span>, the complement of the
language described by the regular expression <span
class="math inline">\(\Sigma^* 0\)</span> is described by the regular
expression <span class="math inline">\(\varepsilon \cup
\Sigma^*1\)</span> because any string that does not end in <span
class="math inline">\(0\)</span> must either be the empty string or end
in <span class="math inline">\(1\)</span>.</p>
<p>For each of the regular expressions <span
class="math inline">\(R\)</span> over the alphabet <span
class="math inline">\(\Sigma = \{0,1\}\)</span> below, write the regular
expression for <span class="math inline">\(\overline{L(R)}\)</span>.
Your regular expressions may use the symbols <span
class="math inline">\(\varnothing\)</span>, <span
class="math inline">\(\varepsilon\)</span>, <span
class="math inline">\(0\)</span>, <span
class="math inline">\(1\)</span>, and the following operations to
combine them: union, concatenation, and Kleene star.</p>
<p>Briefly justify why your solution for each part works by giving plain
English descriptions of the language described by the regular expression
and of its complement and connecting them to the regular expression via
relevant definitions. An English description that is more detailed than
simply negating the description in the original language will likely be
helpful in the justification.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
<span class="math inline">\((\Sigma \Sigma)^*\)</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(\Sigma^* 11 \Sigma^*\)</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(0^* 1 0^* 1 0^*\)</span></p></li>
</ol></li>
<li><p><strong>Closure of the class of regular languages under
intersection</strong> (12 points):<br />
For this question, let <span class="math inline">\(\Sigma =
\{0,1\}\)</span>. Recall the DFA over <span
class="math inline">\(\Sigma\)</span> from the previous homework:</p>
<div class="center">

</div>
<p>We’ll call the language recognized by the DFA above <span
class="math inline">\(A\)</span>. Let’s also define a new language <span
class="math inline">\(B \subseteq \Sigma^*\)</span> to be the language
recognized by the DFA over <span class="math inline">\(\Sigma\)</span>
with state diagram below:</p>
<div class="center">

</div>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Using the
construction for the intersection of two regular languages (Sipser page
46), draw the state diagram for a DFA recognizing the intersection of
the languages <span class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span>. The labels of each one of your states
should be the ordered pair of labels for the states from the two
machines above. Your diagram should have <span
class="math inline">\(6\)</span> states.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) In this part of
the problem, you will prove that the general construction for the DFA
recognizing intersection of two languages that you used in part (a) does
not always produce a DFA with the smallest number of states possible.
You will do this by giving one counterexample (that combined with your
work in part (a), proves the general claim). Your task: design a DFA
with exactly 4 states that recognizes the language <span
class="math inline">\(A \cap B\)</span>. Briefly justify why your design
works by describing the role of each state of your DFA and relating it
to a plain English description of the language resulting from the
intersection.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Later in the class
we will learn that there are some languages which are not regular, and
in fact, we will learn specific techniques to prove that certain
languages are not regular. For the moment, however, we can already
investigate closure properties of the class of regular languages just by
knowing that a non-regular language exists.</p>
<p>We know (from the textbook and our work in class) that if <span
class="math inline">\(L\)</span> and <span
class="math inline">\(K\)</span> are regular languages, then <span
class="math inline">\(L \cap K\)</span> is regular (for arbitrary
languages <span class="math inline">\(L\)</span> and <span
class="math inline">\(K\)</span>). Prove that the converse of this
statement is false; that is, give a counterexample by giving a specific
regular language <span class="math inline">\(L\)</span> so that for each
non-regular language <span class="math inline">\(X\)</span>, <span
class="math inline">\(L \cap X\)</span> is regular (even though <span
class="math inline">\(X\)</span> isn’t).</p>
<p>In your solution, justify why <span class="math inline">\(L\)</span>
is regular and why <span class="math inline">\(L \cap X\)</span> is
regular (for arbitrary <span class="math inline">\(X\)</span>) using
relevant definitions.</p></li>
</ol>
<p><span><em>(Challenge question, not graded) Prove/disprove: For any
language <span class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma^*\)</span>, <span class="math inline">\(L
\cap B\)</span> is regular implies <span
class="math inline">\(L\)</span> is regular, where <span
class="math inline">\(B\)</span> is the specific language from part (a)
and (b) of Problem 2.</em></span></p></li>
<li><p><span><strong>Closure of the class of regular languages
under</strong></span> <span class="smallcaps">Substring</span> (16
points):<br />
Let <span class="math inline">\(\Gamma = \{0,1,2\}\)</span>. From the
previous homework, recall the function <span
class="math inline">\(\textsc{Substring}\)</span> that has domain and
codomain <span class="math inline">\(\mathcal{P}(\Gamma^*)\)</span>,
where, for each language <span class="math inline">\(K\)</span> over
<span class="math inline">\(\Gamma\)</span>, <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}\]</span></p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Consider the NFA
over <span class="math inline">\(\Gamma\)</span> with state diagram:</p>
<div class="center">

</div>
<p>We’ll call the language recognized by the NFA above <span
class="math inline">\(C\)</span>. Fill in the blanks below:</p>
<ul>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is in
<span class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u>
because <u></u></p></li>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is
<span><strong>not</strong></span> in <span
class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u> because
<u></u></p></li>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is
<span><strong>not</strong></span> in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is in
<span class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u>
because <u></u></p></li>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is
<span><strong>not</strong></span> in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is
<span><strong>not</strong></span> in <span
class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u> because
<u></u></p></li>
</ul>
<p>For each item, you’ll either fill in a specific string and a
justification that refers back to the relevant definitions, or you’ll
write “impossible” for the first part of the sentence and justify why
it’s impossible to find such an example referring back to the relevant
definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Prove that the
class of regular languages is closed under the <span
class="math inline">\(\textsc{Substring}\)</span> operation. Namely,
give a general construction that takes an arbitrary NFA and constructs
an NFA that recognizes the result of applying <span
class="math inline">\(\textsc{Substring}\)</span> to the language
recognized by the original machine. You can describe your construction
in words and/or draw a picture to illustrate your construction. You do
not have to write down a formal specification.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Draw the state
diagram of an NFA over <span class="math inline">\(\Gamma\)</span> that
recognizes <span class="math inline">\(\textsc{Substring}(C)\)</span>
(for <span class="math inline">\(C\)</span> the language from part (a)
of this Problem), using your construction from part (b) of this Problem,
or manually constructing it. Describe the computation(s) of this NFA for
each of the sample strings you gave in part (a).</p></li>
</ol></li>
<li><p><span><strong>Closure of the class of regular star-free languages
under</strong></span> <span class="smallcaps">Rep</span> (7
points):<br />
A language is said to be <em>star-free</em> whenever it can be described
by a regular expression that has no Kleene star operations, but where
complement operation can be incorporated into the expression as many
times as you like. For example, the language <span
class="math display">\[\{\varepsilon, 0010\}\]</span> is star-free
because it can be described by <span class="math inline">\(\varepsilon
\cup 0010\)</span> which does not use the Kleene star operation
symbol.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that the set
of all strings over <span class="math inline">\(\Gamma =
\{0,1,2\}\)</span> is star-free. A complete solution will give an
expression that describes this language that does not use Kleene star
but may incoporate the complement expression as many times as you like,
along with a justification that refers back to relevant
definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Prove that every
finite language is star-free.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Let <span
class="math inline">\(\Sigma = \{0,1\}\)</span>. From the previous
homework, recall the function <span
class="math inline">\(\textsc{Rep}\)</span> that has domain <span
class="math inline">\(\mathcal{P}(\Sigma^*)\)</span> and codomain <span
class="math inline">\(\mathcal{P}(\Gamma^*)\)</span>, where, for each
language <span class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span>, <span
class="math display">\[\begin{aligned}
        \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between
every
    pair of successive $2$&#39;s in $w$ is a string in $L$}\}
    
\end{aligned}\]</span></p>
<p>Show that <span class="math inline">\(\textsc{Rep}(L)\)</span> is a
regular and star-free language whenever <span
class="math inline">\(L\)</span> is a regular and star-free language.
That is, given an expression <span class="math inline">\(R\)</span>
describing <span class="math inline">\(L\)</span>, write a regular
expression for <span class="math inline">\(\textsc{Rep}(L)\)</span>
using only the regular expressions <span
class="math inline">\(R\)</span>, <span
class="math inline">\(\varnothing\)</span>, <span
class="math inline">\(\varepsilon\)</span>, <span
class="math inline">\(0\)</span>, <span
class="math inline">\(1\)</span>, <span
class="math inline">\(2\)</span>, and the following operations to
combine them: union, concatenation, and complement. You may assume that
<span class="math inline">\(\overline{R}\)</span> describes <span
class="math inline">\(\Sigma^* -L(R)\)</span>, that is, the complement
for the regular expression <span class="math inline">\(R\)</span> over
the alphabet <span class="math inline">\(\Sigma\)</span> is itself a
language over <span class="math inline">\(\Sigma\)</span>.</p></li>
</ol></li>
</ol>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
</body>
</html>
