<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE105Sp23" />
  <title>HW5 : Turing Machines</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW5 : Turing Machines</h1>
<p class="author">CSE105Sp23</p>
<p class="date">Due: May 16th at 5pm (no penalty late submission until
8am next morning), via Gradescope</p>
</header>
<p><strong>In this assignment:</strong> You will practice designing and
working with Turing machines and their variants.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 5 through Week 6. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Chapter 3. Chapter 3
exercises 3.1, 3.2.</p>
<p><em>Key Concepts:</em> Formal definitions of Turing machines,
computations of Turing machines, halting computations,
implementation-level descriptions of Turing machines, high-level
descriptions of Turing machines, recognizable languages, decidable
languages, variants of Turing machines, enumerators, nondeterministic
Turing machines, Church-Turing thesis.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw5CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><span
class="math inline">\(\textsc{Rep}\)</span>(<strong>Describing a Turing
Machine for</strong> <span class="math inline">\(\textsc{Rep}\)</span>)
(18 points):<br />
Recall that for <span class="math inline">\(L \subseteq
\Sigma^*\)</span> with <span class="math inline">\(\Sigma =
\{0,1\}\)</span>, we define the language over <span
class="math inline">\(\Gamma = \{0,1,2\}\)</span> <span
class="math display">\[\begin{aligned}
\textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every pair
of successive $2$&#39;s in $w$ is a string in $L$}\}\\
&amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in \Sigma^*
\text{ if } 2v2 \in \textsc{Substring}(\{w\})  
\text{, then } v \in L\}
\end{aligned}\]</span> where for all languages <span
class="math inline">\(K \subseteq \Gamma^*\)</span> we let <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}.\]</span></p>
<p>In this question, you will give three separate descriptions of a
Turing machine which recognizes the language <span
class="math inline">\(\textsc{Rep}(\{0^n1^n \mid n \ge
0\})\)</span>.</p>
<p>This may seem like a somewhat tedious process, but we think that it
is important to see all the different descriptions in action at least
once for a single language.</p>
<p>With each description, give a brief justification connecting the
description to the language it recognizes.</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
High-level description: description of algorithm (precise sequence of
instructions), without implementation details of machine. Your
description can use data structures and refer to specific positions in
the input strings (without specifying memory management).</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
Implementation-level description: English prose that describes the
Turing machine head movements relative to contents of tape, and
conditions for accepting / rejecting based on those contents.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Formal definition:
Give the 7-tuple of parameters <span class="math display">\[(Q, \Sigma,
\Gamma, \delta, q_0, q_{\mathrm{acc}}, q_{\mathrm{rej}})\]</span>
describing the Turing Machine. Represent the transition function <span
class="math inline">\(\delta\)</span> by drawing the state diagram of
the Turing machine. You may use the following conventions: omit the
reject state from the diagram; any missing transitions in the state
diagram are assumed to go to the reject state.</p></li>
</ol></li>
<li><p><strong>This Turing Machine is broken... or is it?</strong> (12
points):<br />
Let’s consider a variant of a Turing Machine which models computation
where the data keeps getting corrupted. A Corrupted Turing Machine <span
class="math inline">\(M =
(Q, \Sigma, \Gamma, \delta, q_0, q_{\mathrm{acc}},
q_{\mathrm{rej}})\)</span> has some of the usual Turing Machine
components: set of states (<span class="math inline">\(Q\)</span>);
input alphabet (<span class="math inline">\(\Sigma\)</span>); transition
function (<span class="math inline">\(\delta\)</span>); start state
(<span class="math inline">\(q_0\)</span>); accepting state (<span
class="math inline">\(q_{\mathrm{acc}}\)</span>), rejecting state (<span
class="math inline">\(q_{\mathrm{rej}}\)</span>). Unlike a normal Turing
Machine, the tape alphabet <span class="math inline">\(\Gamma  \supseteq
\Sigma\)</span> has two (rather than one) special characters <span
class="math inline">\(\scalebox{1.5}{\textvisiblespace}\)</span> and
<span class="math inline">\(\text{\lightning}\)</span>:</p>
<ul>
<li><p><span class="math inline">\(\scalebox{1.5}{\textvisiblespace}\in
\Gamma\)</span>, <span
class="math inline">\(\scalebox{1.5}{\textvisiblespace}\not\in
\Sigma\)</span>: This is the usual blank symbol.</p></li>
<li><p><span class="math inline">\(\text{\lightning}\in \Gamma\)</span>,
<span class="math inline">\(\text{\lightning}\not\in \Sigma\)</span>:
This symbol indicates a cell that has been corrupted. The machine cannot
write over any corrupted cell; that is, for each <span
class="math inline">\(q \in Q\)</span>, <span
class="math display">\[\delta(q, \text{\lightning}) \in \{ (r,
\text{\lightning}, D) \mid r \in Q, D \in \{L, R\} \}\]</span></p></li>
</ul>
<p>Computation in the corrupted Turing Machine proceeds as normal except
that sometimes when writing a tape symbol as intended, a <span
class="math inline">\(\text{\lightning}\)</span> symbol is written
instead. Thankfully, the pattern of corruption is predictable: the first
write is corrupted, and then every other write thereafter is corrupted.
That is, the first, third, fifth,... etc. writes are corrupted.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that for
every <span><strong>regular</strong></span> language <span
class="math inline">\(L\)</span>, there exists a corrupted Turing
Machine <span class="math inline">\(M\)</span> that recognizes <span
class="math inline">\(L\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) It will turn out
that the Corrupted Turing Machine is no less powerful than our usual
definition of a Turing Machine. Let’s break the proof into a few steps.
First, define the alphabet <span
class="math inline">\(\Sigma_{\mathrm{pairs}}:= \Sigma \times \Sigma =
\{ (a,b) \mid a \in \Sigma, b \in \Sigma\}\)</span> of pairs of symbols
in <span class="math inline">\(\Sigma\)</span>. Give the construction of
a Corrupted Turing Machine that takes input <span
class="math inline">\(a = a_1 a_2 \cdots a_n \in \Sigma^*\)</span> and
rewrites it as pairs of symbols interspersed by corrupted symbols. To be
precise, the Corrupted Turing Machine should take starting tape
configuration <span class="math display">\[\begin{array}{| c | c | c | c
| c | c | c | c | }  \hline
a_1 &amp; a_2 &amp; \ldots &amp; a_{n-1} &amp; a_{n} &amp;
\scalebox{1.5}{\textvisiblespace}&amp;
\scalebox{1.5}{\textvisiblespace}&amp; \ldots \\ \hline
\end{array}\]</span> to the tape configuration <span
class="math display">\[\begin{array}{| c | c | c | c | c | c | c | c | c
| c | c | c| }  \hline
\text{\lightning}&amp; (a_1, a_2) &amp; \text{\lightning}&amp; (a_3,a_4)
&amp; \text{\lightning}&amp; \ldots&amp; \text{\lightning}
&amp; (a_{n-1}, a_{n}) &amp; \text{\lightning}&amp;
\scalebox{1.5}{\textvisiblespace}&amp;
\scalebox{1.5}{\textvisiblespace}&amp; \ldots \\ \hline
\end{array}\]</span> with the head once again pointing to the first
cell. For simplicity, you may assume that <span
class="math inline">\(n\)</span> is even.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Starting from the
tape configuration we created in the previous step, describe the
implementation of a Corrupted Turing Machine which simulates the
computation of any normal/uncorrupted Turing Machine.</p>
<p><em>Challenge; not graded</em>: A key idea in the construction above
was to increase the number of symbols in our tape alphabet. Can you do
the same construction <em>without</em> increasing the size of the tape
alphabet? That is, for every language <span
class="math inline">\(L\)</span> recognized by a normal Turing machine
over alphabet <span class="math inline">\(\Sigma\)</span> and tape
alphabet <span class="math inline">\(\Sigma \cup
\{\scalebox{1.5}{\textvisiblespace}\}\)</span>, is there a Corrupted
Turing Machine with tape alphabet <span class="math inline">\(\Sigma
\cup \{\scalebox{1.5}{\textvisiblespace},\text{\lightning}\}\)</span>
that recognizes <span class="math inline">\(L\)</span>?</p></li>
</ol></li>
<li><p><strong>True/False enumerator</strong> (20 points):<br />
For each of the following statements, determine if it is true or false.
Clearly label your choice by starting your solution with
<span><strong>True</strong></span> or
<span><strong>False</strong></span> and then provide a brief (3-4
sentences or so) justification for your answer.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Every enumerator
enumerates an infinite language.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(E\)</span> be any enumerator and <span
class="math inline">\(M\)</span> be any Turing machine. If <span
class="math inline">\(L(E) = L(M)\)</span>, then <span
class="math inline">\(M\)</span> enters the reject state for all strings
not in <span class="math inline">\(L(E)\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(E\)</span> be any enumerator over <span
class="math inline">\(\Sigma\)</span>. Suppose <span
class="math inline">\(a, b \in \Sigma^*\)</span> and <span
class="math inline">\(a, b \in L(E)\)</span>. If <span
class="math inline">\(E\)</span> prints <span
class="math inline">\(a\)</span> before <span
class="math inline">\(b\)</span>, then <span class="math inline">\(|a|
\le |b|\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(M\)</span> decide language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> such that <span
class="math inline">\(M\)</span> halts on all inputs <span
class="math inline">\(w \in \Sigma^*\)</span> in <span
class="math inline">\(|w|^{2023}\)</span> steps. There exists an
enumerator <span class="math inline">\(E\)</span> with the following
properties: <span class="math inline">\(L(E) = L(M)\)</span>; and if
<span class="math inline">\(a, b \in L\)</span> and <span
class="math inline">\(|a| &lt; |b|\)</span>, then <span
class="math inline">\(E\)</span> prints <span
class="math inline">\(a\)</span> before <span
class="math inline">\(b\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(N\)</span> be a nondeterministic Turing machine.
There is an enumerator <span class="math inline">\(E\)</span> that
enumerates the set of all and only strings accepted by <span
class="math inline">\(N\)</span> that have odd length.</p></li>
</ol></li>
</ol>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
</body>
</html>
