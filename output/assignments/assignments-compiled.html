<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE105Sp23" />
  <title>assignments-compiled</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW1 : Regular Expressions and Finite AutomataHW2 :
Regular Languages and Automata ConstructionsHW3 : Nonregular Languages
and Pushdown AutomataHW4 : Pushdown Automata and Context-free
grammarsHW5 : Turing MachinesHW6 : Computational Problems,
Recognizability, DecidabilityHW7 : Undecidability, Co-Recognizability,
and Mapping ReductionsProject - CSE 105 Spring 2022</h1>
<p class="author">CSE105Sp23</p>
<p class="date">Due: April 11th at 5pm (no penalty late submission until
8am next morning), via GradescopeDue: April 18th at 5pm (no penalty late
submission until 8am next morning), via GradescopeDue: April 25th at 5pm
(no penalty late submission until 8am next morning), via GradescopeDue:
May 2nd at 5pm (no penalty late submission until 8am next morning), via
GradescopeDue: May 16th at 5pm (no penalty late submission until 8am
next morning), via GradescopeDue: May 23th at 5pm (no penalty late
submission until 8am next morning), via GradescopeDue: June 6th at 5pm
(no penalty late submission until 8am next morning), via GradescopeDue
6/1/23 at 5pm (no penalty late submission until 8am next day)</p>
</header>
<p><span><strong>In this assignment,</strong></span></p>
<p>You will practice reading and applying the definitions of alphabets,
strings, languages, Kleene star, and regular expressions. You will use
regular expressions and relate them to languages and finite automata.
You will use precise notation to formally define the state diagram of
finite automata, and you will use clear English to describe computations
of finite automata informally.</p>
<p><span><strong>Resources</strong></span>: To review the topics for
this assignment, see the class material from Week 1. We will post
frequently asked questions and our answers to them in a pinned Piazza
post.</p>
<p><span><strong>Reading and extra practice problems</strong></span>:
Sipser Section 0, 1.3, 1.1. Chapter 1 exercises 1.1, 1.2, 1.3, 1.18,
1.23.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw1CSE105Sp23”.</p>
<p><span><strong>Assigned questions</strong></span></p>
<ol>
<li><p><strong>Functions over sets of strings</strong> (17
points):<br />
For this question, fix the alphabets <span class="math inline">\(\Sigma
= \{0,1\}\)</span> and <span class="math inline">\(\Gamma =
\{0,1,2\}\)</span>.</p>
<p>Whenever <span class="math inline">\(K\)</span> is a set of strings
over <span class="math inline">\(\Gamma\)</span> and <span
class="math inline">\(L\)</span> is a set of strings over <span
class="math inline">\(\Sigma\)</span>, we can use the following rules to
define associated sets of strings: <span
class="math display">\[\begin{aligned}
    \textsc{Substring}(K) &amp;:= \{ w \in \Gamma^* \mid \text{there
exist } a,b \in \Gamma^* \text{ such that } awb \in K\} \\
    \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every
    pair of successive $2$s in $w$ is a string in $L$}\}\\
    &amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in
\Sigma^* \text{ if } 2v2 \in \textsc{Substring}(\{w\})  \text{, then } v
\in L\}
    
\end{aligned}\]</span> <em>Note:</em> Formally, <span
class="math inline">\(\textsc{Substring}\)</span> and <span
class="math inline">\(\textsc{Rep}\)</span> are functions whose domains
and codomains are specified as <span
class="math display">\[\textsc{Substring}: \mathcal{P}(\Gamma^*) \to
\mathcal{P}(\Gamma^*)\]</span> and <span
class="math display">\[\textsc{Rep}: \mathcal{P}(\Sigma^*) \to
\mathcal{P}(\Gamma^*)\]</span> In other words, <span
class="math inline">\(\textsc{Substring}\)</span> maps sets of strings
with characters <span class="math inline">\(\{0,1,2\}\)</span> to
associated sets of strings with characters <span
class="math inline">\(\{0,1,2\}\)</span>; and <span
class="math inline">\(\textsc{Rep}\)</span> maps sets of strings with
characters in <span class="math inline">\(\{0,1\}\)</span> to associated
sets of strings with characters in <span
class="math inline">\(\{0,1,2\}\)</span>.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
Consider <span class="math inline">\(w = 0120\)</span> (which is a
string in <span class="math inline">\(\Gamma^*\)</span>). List every
element of the set <span
class="math inline">\(\textsc{Substring}(\{w\})\)</span>. In other
words, fill in the blank <span
class="math display">\[\textsc{Substring}(\{w\}) = \{
\underline{\phantom{\hspace{3in}}} \}\]</span> Briefly justify your
answer by referring back to the relevant definitions.</p>
<p><span><em>Not graded, but good to think about: Why do we need the
curly braces—“<span class="math inline">\(\{\)</span>” and “<span
class="math inline">\(\}\)</span>”—around <span
class="math inline">\(w\)</span> for the input to <span
class="math inline">\(\textsc{Substring}\)</span>?</em></span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Specify an example
language <span class="math inline">\(A\)</span> over <span
class="math inline">\(\Gamma\)</span> such that <span
class="math inline">\(A \neq \Gamma^*\)</span> and yet <span
class="math inline">\(\textsc{Substring}(A) = \Gamma^*\)</span>, or
explain why there is no such example. A complete solution will include
either (1) a precise and clear description of your example language
<span class="math inline">\(A\)</span> and a precise and clear
description of the result of computing <span
class="math inline">\(\textsc{Substring}(A)\)</span> using relevant
definitions to justify this description and to justify the set equality
with <span class="math inline">\(\Gamma^*\)</span>, or (2) a
sufficiently general and correct argument why there is no such example,
referring back to the relevant definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
Define the language <span class="math inline">\(B\)</span> to be the
language over <span class="math inline">\(\Sigma\)</span> described by
the regular expression <span class="math display">\[\Sigma^* 1
\Sigma^*\]</span> In plain English, we might explain that <span
class="math inline">\(B\)</span> is the set of all strings of <span
class="math inline">\(0\)</span>s and <span
class="math inline">\(1\)</span>s that contain a <span
class="math inline">\(1\)</span>. Give a plain English explanation for
the set of strings <span
class="math inline">\(\textsc{Rep}(B)\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Prove/disprove:
For every finite language <span class="math inline">\(L\)</span> over
<span class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\textsc{Rep}(L)\)</span> is also a finite set of
strings. A complete answer will either give a general argument starting
with an arbitrary finite language and proving that the result of
applying <span class="math inline">\(\textsc{Rep}\)</span> is also
finite, or will give a counterexample (which is a specific example of a
finite language <span class="math inline">\(L\)</span> for which
applying <span class="math inline">\(\textsc{Rep}\)</span> gives an
infinite language, with justification referring back to the relevant
definitions).</p>
<p><span><em>Note: A finite language is a set of finitely many strings.
This includes the possibility that <span
class="math inline">\(L\)</span> is the empty set!</em></span></p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Write a template
for a regular expression that describes <span
class="math inline">\(\textsc{Rep}(L)\)</span> when <span
class="math inline">\(L\)</span> is described by a regular expression
<span class="math inline">\(R\)</span>. You may use union,
concatenation, Kleene star, and <span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\Gamma\)</span>, and <span
class="math inline">\(R\)</span>. (We’re using the shorthand for regular
expressions describing alphabets from page 64.)</p></li>
</ol></li>
<li><p><strong>Deciphering regular expressions</strong> (22
points):<br />
For this question, let’s fix the regular expression over the alphabet
<span class="math inline">\(\{0,1\}\)</span> <span
class="math display">\[R = 0^* (1 \cup 10)^*\]</span></p>
<p>For each choice of strings of length <span
class="math inline">\(3\)</span>, <span class="math inline">\(a, b, c
\in \{0,1\}^3\)</span> we can define the regular expression: <span
class="math display">\[X_{a,b,c} = 0 (a \cup b \cup c)^*\]</span></p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) Give a plain
English explanation for the language described by the regular expression
<span class="math inline">\(R\)</span>. This continues a theme from
Problem 1—before trying to prove formal statements about a specific
regular expression, it’s often good to try to translate it into a form
that is more easy to reason about. Typically speaking, the shorter and
more concise your plain English description is, the more useful it will
be in reasoning about the language.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Suppose <span
class="math inline">\(a = 000\)</span>, <span
class="math inline">\(b=001\)</span>, <span
class="math inline">\(c=011\)</span> so <span
class="math display">\[X_{a,b,c} = 0 ( 000 \cup 001 \cup 011)^*\]</span>
Show that <span class="math inline">\(L(R) \not\subseteq
L(X_{a,b,c})\)</span> by giving some string in <span
class="math inline">\(L(R)\)</span> which is not in <span
class="math inline">\(L(X_{a,b,c})\)</span>, and justifying this choice
referring back to relevant definitions.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) More generally,
prove that <span class="math display">\[L(R) \not\subseteq
L(X_{a,b,c})\]</span> for <em>all</em> possible strings <span
class="math inline">\(a, b, c \in \{0,1\}^3\)</span>. Hint: What are the
possible lengths of strings in <span class="math inline">\(L(R)\)</span>
(and why does this help)?</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Give a specific
example of three distinct strings <span class="math inline">\(a, b, c
\in \{0,1,2\}^3\)</span> such that <span
class="math display">\[L(X_{a,b,c}) \subseteq L(R)\]</span> Briefly
justify your answer by explaining how an arbitrary element of <span
class="math inline">\(L(X_{a,b,c})\)</span> is guaranteed to be an
element of <span class="math inline">\(L(R)\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Give a specific
example of three distinct strings <span class="math inline">\(a, b, c
\in \{0,1,2\}^3\)</span> such that <span
class="math display">\[L(X_{a,b,c}) \not\subseteq L(R)\]</span> Briefly
justify your answer by giving a counterexample string that is in <span
class="math inline">\(L(X_{a,b,c})\)</span> and is not in <span
class="math inline">\(L(R)\)</span> (and explaining why using relevant
definitions).</p></li>
</ol></li>
<li><p><strong>The right transition function can make or break a
DFA</strong> (6 points):<br />
Consider the finite automaton <span class="math inline">\((Q, \Sigma,
\delta, q_0, F)\)</span> depicted below</p>
<div class="center">

</div>
<p>where <span class="math inline">\(Q = \{q_0, q_1, q_2\}\)</span>,
<span class="math inline">\(\Sigma = \{0,1\}\)</span>, and <span
class="math inline">\(F = \{q_0\}\)</span>.</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) Find and fix the
mistake in the following symbolic description of the transition function
<span class="math inline">\(\delta \colon Q \times \Sigma \to
Q\)</span>: for each <span class="math inline">\(j \in \{0,1\}\)</span>
<span class="math display">\[\delta(q_0, j) = q_j \hspace{2cm}
\delta(q_1, j) = q_{1-j} \hspace{2cm} \delta(q_2, j) =
q_{1+j}\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Keeping the same
set of states <span class="math inline">\(Q = \{q_0, q_1,
q_2\}\)</span>, alphabet <span class="math inline">\(\Sigma =
\{0,1\}\)</span>, starting state <span
class="math inline">\(q_0\)</span>, and set of accepting states <span
class="math inline">\(F = \{q_0\}\)</span>, change the transition
function <span class="math inline">\(\delta\)</span> so that the
resulting finite automaton recognizes the language described by the
regular expression <span class="math display">\[0^* \cup \Sigma^*
1000^*\]</span> Briefly justify why the resulting finite automaton works
by describing the role of each state with your new transition function
and relating it to a plain English description of the language described
by the regular expression.</p>
<p>Note: with regular expressions <span class="math inline">\(*\)</span>
binds more tightly than concatenation so <span
class="math inline">\(1000^* = (100)(0^*)\)</span>.</p></li>
</ol>
<p><span><em>(Challenge question, not graded) There is a beautiful plain
English description of the language recognized by the finite automaton
with the state diagram depicted at the start of Problem 3. What is
it?</em></span></p></li>
<li><p><strong>Being precise with terminology</strong> (5 points):<br />
For each of the following statements, determine if it is true, false, or
if the question doesn’t even make sense (because the statement isn’t
well formed or doesn’t use terms in ways consistent with definitions
from class).</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) The empty string
is in every language.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <span
class="math inline">\(\Sigma^*\)</span> is a language.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Every language is
a regular expression.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Alphabets are
infinite.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) There is a
(finite) number <span class="math inline">\(k \in \mathcal N\)</span>
such that every DFA has fewer than <span
class="math inline">\(k\)</span> states.</p></li>
</ol></li>
</ol>
<p>You will practice designing multiple representations of regular
languages and working with general constructions of automata to
demonstrate the richness of the class of regular languages.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 1 and Week 2. We will
post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Sipser Section 1.1,
1.2, 1.3. Chapter 1 exercises 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11,
1.12, 1.14, 1.15, 1.16, 1.17, 1.19, 1.20, 1.21, 1.22.</p>
<p><em>Key Concepts:</em> Regular expressions, language described by a
regular expression, deterministic finite automata (DFAs), regular
languages, closure of the class of regular languages under certain
operations, nondeterministic finite automata (NFA).</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw2CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>It can be hard to give a good complement</strong> (15
points):<br />
For any language <span class="math inline">\(L \subseteq
\Sigma^*\)</span>, recall that we define its <em>complement</em> as
<span class="math display">\[\overline{L} := \Sigma^* - L = \{w \in
\Sigma^* \mid w \notin L\}\]</span> That is, the complement of <span
class="math inline">\(L\)</span> contains all and only those strings
which are not in <span class="math inline">\(L\)</span>. Our notation
for regular expressions does not include the complement symbol. However,
it turns out that the complement of a language described by a regular
expression is guaranteed to also be describable by a (different) regular
expression. For example, over the alphabet <span
class="math inline">\(\Sigma = \{0,1\}\)</span>, the complement of the
language described by the regular expression <span
class="math inline">\(\Sigma^* 0\)</span> is described by the regular
expression <span class="math inline">\(\varepsilon \cup
\Sigma^*1\)</span> because any string that does not end in <span
class="math inline">\(0\)</span> must either be the empty string or end
in <span class="math inline">\(1\)</span>.</p>
<p>For each of the regular expressions <span
class="math inline">\(R\)</span> over the alphabet <span
class="math inline">\(\Sigma = \{0,1\}\)</span> below, write the regular
expression for <span class="math inline">\(\overline{L(R)}\)</span>.
Your regular expressions may use the symbols <span
class="math inline">\(\varnothing\)</span>, <span
class="math inline">\(\varepsilon\)</span>, <span
class="math inline">\(0\)</span>, <span
class="math inline">\(1\)</span>, and the following operations to
combine them: union, concatenation, and Kleene star.</p>
<p>Briefly justify why your solution for each part works by giving plain
English descriptions of the language described by the regular expression
and of its complement and connecting them to the regular expression via
relevant definitions. An English description that is more detailed than
simply negating the description in the original language will likely be
helpful in the justification.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
<span class="math inline">\((\Sigma \Sigma)^*\)</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(\Sigma^* 11 \Sigma^*\)</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(0^* 1 0^* 1 0^*\)</span></p></li>
</ol></li>
<li><p><strong>Closure of the class of regular languages under
intersection</strong> (12 points):<br />
For this question, let <span class="math inline">\(\Sigma =
\{0,1\}\)</span>. Recall the DFA over <span
class="math inline">\(\Sigma\)</span> from the previous homework:</p>
<div class="center">

</div>
<p>We’ll call the language recognized by the DFA above <span
class="math inline">\(A\)</span>. Let’s also define a new language <span
class="math inline">\(B \subseteq \Sigma^*\)</span> to be the language
recognized by the DFA over <span class="math inline">\(\Sigma\)</span>
with state diagram below:</p>
<div class="center">

</div>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Using the
construction for the intersection of two regular languages (Sipser page
46), draw the state diagram for a DFA recognizing the intersection of
the languages <span class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span>. The labels of each one of your states
should be the ordered pair of labels for the states from the two
machines above. Your diagram should have <span
class="math inline">\(6\)</span> states.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) In this part of
the problem, you will prove that the general construction for the DFA
recognizing intersection of two languages that you used in part (a) does
not always produce a DFA with the smallest number of states possible.
You will do this by giving one counterexample (that combined with your
work in part (a), proves the general claim). Your task: design a DFA
with exactly 4 states that recognizes the language <span
class="math inline">\(A \cap B\)</span>. Briefly justify why your design
works by describing the role of each state of your DFA and relating it
to a plain English description of the language resulting from the
intersection.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Later in the class
we will learn that there are some languages which are not regular, and
in fact, we will learn specific techniques to prove that certain
languages are not regular. For the moment, however, we can already
investigate closure properties of the class of regular languages just by
knowing that a non-regular language exists.</p>
<p>We know (from the textbook and our work in class) that if <span
class="math inline">\(L\)</span> and <span
class="math inline">\(K\)</span> are regular languages, then <span
class="math inline">\(L \cap K\)</span> is regular (for arbitrary
languages <span class="math inline">\(L\)</span> and <span
class="math inline">\(K\)</span>). Prove that the converse of this
statement is false; that is, give a counterexample by giving a specific
regular language <span class="math inline">\(L\)</span> so that for each
non-regular language <span class="math inline">\(X\)</span>, <span
class="math inline">\(L \cap X\)</span> is regular (even though <span
class="math inline">\(X\)</span> isn’t).</p>
<p>In your solution, justify why <span class="math inline">\(L\)</span>
is regular and why <span class="math inline">\(L \cap X\)</span> is
regular (for arbitrary <span class="math inline">\(X\)</span>) using
relevant definitions.</p></li>
</ol>
<p><span><em>(Challenge question, not graded) Prove/disprove: For any
language <span class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma^*\)</span>, <span class="math inline">\(L
\cap B\)</span> is regular implies <span
class="math inline">\(L\)</span> is regular, where <span
class="math inline">\(B\)</span> is the specific language from part (a)
and (b) of Problem 2.</em></span></p></li>
<li><p><span><strong>Closure of the class of regular languages
under</strong></span> <span class="smallcaps">Substring</span> (16
points):<br />
Let <span class="math inline">\(\Gamma = \{0,1,2\}\)</span>. From the
previous homework, recall the function <span
class="math inline">\(\textsc{Substring}\)</span> that has domain and
codomain <span class="math inline">\(\mathcal{P}(\Gamma^*)\)</span>,
where, for each language <span class="math inline">\(K\)</span> over
<span class="math inline">\(\Gamma\)</span>, <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}\]</span></p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Consider the NFA
over <span class="math inline">\(\Gamma\)</span> with state diagram:</p>
<div class="center">

</div>
<p>We’ll call the language recognized by the NFA above <span
class="math inline">\(C\)</span>. Fill in the blanks below:</p>
<ul>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is in
<span class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u>
because <u></u></p></li>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is
<span><strong>not</strong></span> in <span
class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u> because
<u></u></p></li>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is
<span><strong>not</strong></span> in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is in
<span class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u>
because <u></u></p></li>
<li><p>An example of a string over <span
class="math inline">\(\Gamma\)</span> that is
<span><strong>not</strong></span> in <span
class="math inline">\(C\)</span> <span><strong>and</strong></span> is
<span><strong>not</strong></span> in <span
class="math inline">\(\textsc{Substring}(C)\)</span> is <u></u> because
<u></u></p></li>
</ul>
<p>For each item, you’ll either fill in a specific string and a
justification that refers back to the relevant definitions, or you’ll
write “impossible” for the first part of the sentence and justify why
it’s impossible to find such an example referring back to the relevant
definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Prove that the
class of regular languages is closed under the <span
class="math inline">\(\textsc{Substring}\)</span> operation. Namely,
give a general construction that takes an arbitrary NFA and constructs
an NFA that recognizes the result of applying <span
class="math inline">\(\textsc{Substring}\)</span> to the language
recognized by the original machine. You can describe your construction
in words and/or draw a picture to illustrate your construction. You do
not have to write down a formal specification.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Draw the state
diagram of an NFA over <span class="math inline">\(\Gamma\)</span> that
recognizes <span class="math inline">\(\textsc{Substring}(C)\)</span>
(for <span class="math inline">\(C\)</span> the language from part (a)
of this Problem), using your construction from part (b) of this Problem,
or manually constructing it. Describe the computation(s) of this NFA for
each of the sample strings you gave in part (a).</p></li>
</ol></li>
<li><p><span><strong>Closure of the class of regular star-free languages
under</strong></span> <span class="smallcaps">Rep</span> (7
points):<br />
A language is said to be <em>star-free</em> whenever it can be described
by a regular expression that has no Kleene star operations, but where
complement operation can be incorporated into the expression as many
times as you like. For example, the language <span
class="math display">\[\{\varepsilon, 0010\}\]</span> is star-free
because it can be described by <span class="math inline">\(\varepsilon
\cup 0010\)</span> which does not use the Kleene star operation
symbol.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that the set
of all strings over <span class="math inline">\(\Gamma =
\{0,1,2\}\)</span> is star-free. A complete solution will give an
expression that describes this language that does not use Kleene star
but may incoporate the complement expression as many times as you like,
along with a justification that refers back to relevant
definitions.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Prove that every
finite language is star-free.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Let <span
class="math inline">\(\Sigma = \{0,1\}\)</span>. From the previous
homework, recall the function <span
class="math inline">\(\textsc{Rep}\)</span> that has domain <span
class="math inline">\(\mathcal{P}(\Sigma^*)\)</span> and codomain <span
class="math inline">\(\mathcal{P}(\Gamma^*)\)</span>, where, for each
language <span class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span>, <span
class="math display">\[\begin{aligned}
        \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between
every
    pair of successive $2$&#39;s in $w$ is a string in $L$}\}
    
\end{aligned}\]</span></p>
<p>Show that <span class="math inline">\(\textsc{Rep}(L)\)</span> is a
regular and star-free language whenever <span
class="math inline">\(L\)</span> is a regular and star-free language.
That is, given an expression <span class="math inline">\(R\)</span>
describing <span class="math inline">\(L\)</span>, write a regular
expression for <span class="math inline">\(\textsc{Rep}(L)\)</span>
using only the regular expressions <span
class="math inline">\(R\)</span>, <span
class="math inline">\(\varnothing\)</span>, <span
class="math inline">\(\varepsilon\)</span>, <span
class="math inline">\(0\)</span>, <span
class="math inline">\(1\)</span>, <span
class="math inline">\(2\)</span>, and the following operations to
combine them: union, concatenation, and complement. You may assume that
<span class="math inline">\(\overline{R}\)</span> describes <span
class="math inline">\(\Sigma^* -L(R)\)</span>, that is, the complement
for the regular expression <span class="math inline">\(R\)</span> over
the alphabet <span class="math inline">\(\Sigma\)</span> is itself a
language over <span class="math inline">\(\Sigma\)</span>.</p></li>
</ol></li>
</ol>
<p><strong>In this assignment:</strong></p>
<p>You will practice distinguishing between regular and nonregular
languages using both closure arguments and the pumping lemma.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 2 through Week 4. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Sipser Section 1.4,
2.2. Chapter 1 exercises 1.29, 1.30. Chapter 1 problems 1.49, 1.50,
1.51.</p>
<p><em>Key Concepts:</em> Pumping lemma, pumping length, regular
languages, nonregular languages, pushdown automata, stack.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw3CSE105Sp23”.</p>
<p><strong>Requests from your TAs and tutors</strong> To help us with
grading please</p>
<ul>
<li><p>Start each question on a new page.</p></li>
<li><p>Label the start of each solution with
<span><strong>Answer</strong></span>.</p></li>
</ul>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>Regular or not?</strong> (21 points):<br />
Fix <span class="math inline">\(\Sigma = \{0,1\}\)</span> and <span
class="math inline">\(\Gamma = \{0,1,2\}\)</span>. For each of the
languages listed below, prove that it is either regular or nonregular.
<span><em>Note:</em></span> You might find it useful to explore the
definition of each set and consider alternate (simpler) ways of stating
it.</p>
<p>For each language that is regular, a complete solution will include a
precise definition of a DFA, NFA, or regular expression that recognizes
or describes it, along with a brief justification of your construction
by explaining the role each state plays in the machine or referring back
to relevant definitions.</p>
<p>For each language that is nonregular, a complete solution will use
the pumping lemma to prove that it is nonregular, including appropriate
justification related to the specific language.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>
<span class="math inline">\(L_1 = \{0^n x 1^n \mid n \ge 1, x \in
\Sigma^*\}\)</span>, a language over <span
class="math inline">\(\Sigma\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(L_2 = \{0^n 1 x 0 1^n \mid n
    \ge 1, x \in \Sigma^* \}\)</span>, a language over <span
class="math inline">\(\Sigma\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Recall that for
<span class="math inline">\(L \subseteq \Sigma^*\)</span>, we define
<span class="math display">\[\begin{aligned}
    \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every
pair of successive $2$&#39;s in $w$ is a string in $L$}\}\\
    &amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in
\Sigma^* \text{ if } 2v2 \in \textsc{Substring}(\{w\})  \text{, then } v
\in L\}
    
\end{aligned}\]</span> <span class="math inline">\(L_3 = \textsc{Rep}(
\{ 0^n 1^n \mid n \geq 1 \} )\)</span>, a language over <span
class="math inline">\(\Gamma\)</span>.</p></li>
</ol></li>
<li><p><strong>Properties of nonregular languages</strong> (21
points):<br />
Prove or disprove each of the following statements. In other words,
decide whether each statement is true or false and justify your
decision. Let <span class="math inline">\(\Sigma = \{0,1\}\)</span> and
let <span class="math inline">\(\Gamma = \{0,1,2\}\)</span>.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) For all languages
<span class="math inline">\(L, K\)</span> over <span
class="math inline">\(\Sigma\)</span>, if <span
class="math inline">\(L\)</span> is nonregular and <span
class="math inline">\(K\)</span> is finite, then <span
class="math inline">\(L - K\)</span> is nonregular. Recall: <span
class="math inline">\(L - K = \{ w \in \Sigma^* \mid w \in L \text{ and
} w \notin K\}\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Every infinite
language over <span class="math inline">\(\Sigma\)</span> where each
string in the language has an equal number of <span
class="math inline">\(0\)</span>’s and <span
class="math inline">\(1\)</span>’s is nonregular.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Recall that for
language <span class="math inline">\(K\)</span> over <span
class="math inline">\(\Gamma\)</span>, <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}.\]</span> For every nonregular language <span
class="math inline">\(K\)</span> over <span
class="math inline">\(\Gamma\)</span>, <span
class="math inline">\(\textsc{Substring}(K)\)</span> is
nonregular.</p></li>
</ol></li>
<li><p><strong>Pumping dilemma</strong> (8 points):<br />
Your friend claims that the Pumping Lemma is useless for proving that an
infinite language <span class="math inline">\(K \subseteq
\Sigma^*\)</span> is not regular. Their logic goes like this</p>
<ol>
<li><p>Suppose that <span class="math inline">\(K\)</span> is regular.
It can be recognized by a DFA <span class="math inline">\(M = (Q,
\Sigma, \delta, q_0, F)\)</span>.</p></li>
<li><p>For arbitrary DFA <span class="math inline">\(M\)</span>, the
pumping length <span class="math inline">\(p\)</span> is at least <span
class="math inline">\(|Q|\)</span>.</p></li>
<li><p>However, for every integer <span class="math inline">\(n \ge
|Q|\)</span>, there exists a machine <span class="math inline">\(M&#39;
= (Q&#39;, \Sigma, \delta&#39;, q_0&#39;, F&#39;)\)</span> such that
<span class="math inline">\(L(M&#39;) = L(M) = K\)</span> and <span
class="math inline">\(|Q&#39;| = n\)</span>.</p></li>
<li><p>Therefore, the Pumping Lemma cannot be used to pump any string of
finite length since its pumping length might be arbitrarily
large.</p></li>
</ol>
<p>Below, we will examine the steps above in detail. Justify your answer
to each part.</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>
(Step 1): Is this statement true? In other words, just because we’re
assuming that <span class="math inline">\(K\)</span> is regular a
regular language, does it mean we can assume there is a DFA that
recognizes it?</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) (Step 2): In
general, it’s true that the smallest the pumping length of a language
recognized by a DFA with states <span class="math inline">\(Q\)</span>
can be is <span class="math inline">\(|Q|\)</span>. Prove this by
finding a specific infinite language <span
class="math inline">\(K\)</span> and a DFA recognizing where <span
class="math inline">\(K\)</span> cannot have pumping length smaller than
<span class="math inline">\(|Q|\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) (Step 3): This
step is correct; prove the stated version of this statement: For every
integer <span class="math inline">\(n \ge |Q|\)</span>, there exists a
machine <span class="math inline">\(M&#39; = (Q&#39;, \Sigma,
\delta&#39;, q_0&#39;, F&#39;)\)</span> such that <span
class="math inline">\(L(M&#39;) = L(M)\)</span> and <span
class="math inline">\(|Q&#39;| = n\)</span>.</p>
<p>(<em>Challenge; not graded</em>): Define a <em>cycle</em> to be a
sequence of <em>distinct</em> states <span class="math inline">\(q_1,
q_2, \ldots, q_m\)</span> such that <span
class="math display">\[\delta(q_1, \sigma_1) = q_2, \hspace{1cm}
\delta(q_2, \sigma_2) = q_3, \hspace{.5cm} \ldots,
\hspace{.5cm}\delta(q_m, \sigma_m) = q_1,\]</span> where <span
class="math inline">\(\sigma_1, \sigma_2, \ldots, \sigma_m \in
\Sigma\)</span> are symbols in the alphabet. An objection to the
statement in (Step 3) is that the proof of the Pumping Lemma depends on
the length of the cycles in the DFA rather than the number of states.
That is, increasing the number of states in your DFA might not increase
the pumping length because the length of the smallest cycle stays the
same. Nevertheless, a version of your friend’s statement is still true
whenever you impose this additional cycle constraint: for every integer
<span class="math inline">\(n \ge |Q|\)</span>, there exists a machine
<span class="math inline">\(M&#39; = (Q&#39;, \Sigma, \delta&#39;,
q_0&#39;, F&#39;)\)</span> such that <span
class="math inline">\(L(M&#39;) = L(M)\)</span> and the length of the
smallest cycle in the <span class="math inline">\(M&#39;\)</span> is at
least <span class="math inline">\(n\)</span>.<br />
Your task is to show that even this more general statement is true for
the simple language <span class="math inline">\(\Sigma^*\)</span>
recognized by the DFA below:</p>
<div class="center">

</div>
<p>For all <span class="math inline">\(n \ge 1\)</span>, define a DFA
for this language where the length of the smallest cycle is <span
class="math inline">\(n\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) (Step 4):
Describe why this statement is true/false/misleading.</p></li>
</ol></li>
</ol>
<p><strong>In this assignment:</strong></p>
<p>You will practice with the definition of pushdown automata and
context-free grammars and reason about regular and context-free
languages.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 3 through Week 4. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Sipser Sections 2.1,
2.2. Chapter 2 exercises 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.9, 2.10,
2.11, 2.12, 2.13, 2.16, 2.17.</p>
<p><em>Key Concepts:</em> Pushdown automata, stack, context-free
grammars, derivations, context-free languages.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw4CSE105Sp23”.</p>
<p><strong>Requests from your TAs and tutors</strong> To help us with
grading please</p>
<ul>
<li><p>Start each question on a new page.</p></li>
<li><p>Label the start of each solution with
<span><strong>Answer</strong></span>.</p></li>
</ul>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>A PDA with multiple possibilities</strong> (22
points):<br />
Consider the PDA with input and stack alphabet <span
class="math inline">\(\Gamma = \{0,1,2\}\)</span> whose “unfinished"
state diagram is given below:</p>
<div class="center">

</div>
<p>There are three labels (<span class="math inline">\(E_1\)</span>,
<span class="math inline">\(E_2\)</span>, and <span
class="math inline">\(E_3\)</span>) on the edges that are unspecified.
To be precise, each <span class="math inline">\(E_i\)</span> is of the
form “<span class="math inline">\(x,y; z\)</span>” where <span
class="math inline">\(x, y, z \in \Gamma_{\varepsilon}\)</span> (recall
<span class="math inline">\(\Gamma_{\varepsilon} = \Gamma \cup
\{\varepsilon\}\)</span>).</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>
Prove that (no matter how the labels <span class="math inline">\(E_1,
E_2, E_3\)</span> are specified), the language recognized by this PDA is
infinite. A complete solution will include a precise description of an
infinite collection of strings each of which is accepted by the PDA,
with a precise and clear description of the accepting computation of the
PDA on each of these strings.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn7"
class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>
Prove/Disprove: Over all the possible choices for the labels <span
class="math inline">\(E_1, E_2, E_3\)</span>, this PDA can only
recognize finitely many languages. Justify your solution by referring
back to the relevant definitions.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Recall that for
<span class="math inline">\(L \subseteq \Sigma^*\)</span> with <span
class="math inline">\(\Sigma = \{0,1\}\)</span>, we define <span
class="math display">\[\begin{aligned}
    \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every
pair of successive $2$&#39;s in $w$ is a string in $L$}\}\\
    &amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in
\Sigma^* \text{ if } 2v2 \in \textsc{Substring}(\{w\})  \text{, then } v
\in L\}
    
\end{aligned}\]</span> where for all languages <span
class="math inline">\(K \subseteq \Gamma^*\)</span> we let <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}.\]</span></p>
<p>Determine how to set the labels <span class="math inline">\(E_1, E_2,
E_3\)</span> so that the language of the PDA is <span
class="math display">\[\textsc{Rep}(\{0^n1^m \mid n \ge 0, m \ge
0\})\]</span> In addition to specifying each <span
class="math inline">\(E_i\)</span>, a complete justification will
include a precise description of why this choice of the <span
class="math inline">\(E_i\)</span>’s means that the PDA recognizes the
language indicated.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Determine how to
set the labels <span class="math inline">\(E_1, E_2, E_3\)</span> so
that the language of the PDA is <span
class="math display">\[\textsc{Rep}(\{0^n1^n \mid n \ge 0\})\]</span> In
addition to specifying each <span class="math inline">\(E_i\)</span>, a
complete justification will include a precise description of why this
choice of the <span class="math inline">\(E_i\)</span>’s means that the
PDA recognizes the language indicated.</p></li>
</ol></li>
<li><p><strong>Grammar practice</strong> (12 points):<br />
For each of the languages listed below, define a context-free grammar
<span class="math inline">\(G = (V, \Sigma, R, S)\)</span> that
generates the language. Instead of formally justifying your grammar,
illustrate it by giving <span><strong>two examples</strong></span> of
strings in the language and their derivations using your grammar and
<span><strong>one example</strong></span> of a string not in the
language with an explanation of why it cannot appear on the right side
of any derivation in your grammar. Choose your examples so they are
different enough to illustrate the role of as many of the variables in
your grammar as possible.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(\textsc{Rep}(\{0^n1^n \mid n \ge
0\})\)</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(\{1^n = 1^a + 1^b \in \{1,=,+\}^* \mid a,b,n \ge 1
\text{ such that } a + b = n \}\)</span></p></li>
</ol></li>
<li><p><strong>Substrings and regularity</strong> (16 points):<br />
For this problem, we fix the alphabet <span class="math inline">\(\Gamma
= \{0,1,2\}\)</span>. Recall the definition of the function <span
class="math inline">\(\textsc{Substring}\)</span> from Problem 1.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that <span
class="math inline">\(\textsc{Substring}(\{ 0^n 1^n \mid n \ge
0\})\)</span> is regular. A complete solution will include a precise
definition of a DFA, NFA, or regular expression that recognizes or
describes it, along with a brief justification of your construction by
explaining the role each state plays in the machine and referring back
to relevant definitions.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that <span
class="math inline">\(\textsc{Substring}(\{ 0^n 1^n 2^n \mid n \ge
0\})\)</span> is not regular.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Is <span
class="math inline">\(\textsc{Substring}(\{ 0^n 1^n 2^n \mid n \ge
0\})\)</span> context-free? Informally justify your answer, referring to
class discussions and/or the textbook.</p></li>
</ol></li>
</ol>
<p><strong>In this assignment:</strong> You will practice designing and
working with Turing machines and their variants.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 5 through Week 6. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Chapter 3. Chapter 3
exercises 3.1, 3.2.</p>
<p><em>Key Concepts:</em> Formal definitions of Turing machines,
computations of Turing machines, halting computations,
implementation-level descriptions of Turing machines, high-level
descriptions of Turing machines, recognizable languages, decidable
languages, variants of Turing machines, enumerators, nondeterministic
Turing machines, Church-Turing thesis.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw5CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><span
class="math inline">\(\textsc{Rep}\)</span>(<strong>Describing a Turing
Machine for</strong> <span class="math inline">\(\textsc{Rep}\)</span>)
(18 points):<br />
Recall that for <span class="math inline">\(L \subseteq
\Sigma^*\)</span> with <span class="math inline">\(\Sigma =
\{0,1\}\)</span>, we define the language over <span
class="math inline">\(\Gamma = \{0,1,2\}\)</span> <span
class="math display">\[\begin{aligned}
\textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every pair
of successive $2$&#39;s in $w$ is a string in $L$}\}\\
&amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in \Sigma^*
\text{ if } 2v2 \in \textsc{Substring}(\{w\})  
\text{, then } v \in L\}
\end{aligned}\]</span> where for all languages <span
class="math inline">\(K \subseteq \Gamma^*\)</span> we let <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}.\]</span></p>
<p>In this question, you will give three separate descriptions of a
Turing machine which recognizes the language <span
class="math inline">\(\textsc{Rep}(\{0^n1^n \mid n \ge
0\})\)</span>.</p>
<p>This may seem like a somewhat tedious process, but we think that it
is important to see all the different descriptions in action at least
once for a single language.</p>
<p>With each description, give a brief justification connecting the
description to the language it recognizes.</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
High-level description: description of algorithm (precise sequence of
instructions), without implementation details of machine. Your
description can use data structures and refer to specific positions in
the input strings (without specifying memory management).</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn9"
class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>
Implementation-level description: English prose that describes the
Turing machine head movements relative to contents of tape, and
conditions for accepting / rejecting based on those contents.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Formal definition:
Give the 7-tuple of parameters <span class="math display">\[(Q, \Sigma,
\Gamma, \delta, q_0, q_{\mathrm{acc}}, q_{\mathrm{rej}})\]</span>
describing the Turing Machine. Represent the transition function <span
class="math inline">\(\delta\)</span> by drawing the state diagram of
the Turing machine. You may use the following conventions: omit the
reject state from the diagram; any missing transitions in the state
diagram are assumed to go to the reject state.</p></li>
</ol></li>
<li><p><strong>This Turing Machine is broken... or is it?</strong> (12
points):<br />
Let’s consider a variant of a Turing Machine which models computation
where the data keeps getting corrupted. A Corrupted Turing Machine <span
class="math inline">\(M =
(Q, \Sigma, \Gamma, \delta, q_0, q_{\mathrm{acc}},
q_{\mathrm{rej}})\)</span> has some of the usual Turing Machine
components: set of states (<span class="math inline">\(Q\)</span>);
input alphabet (<span class="math inline">\(\Sigma\)</span>); transition
function (<span class="math inline">\(\delta\)</span>); start state
(<span class="math inline">\(q_0\)</span>); accepting state (<span
class="math inline">\(q_{\mathrm{acc}}\)</span>), rejecting state (<span
class="math inline">\(q_{\mathrm{rej}}\)</span>). Unlike a normal Turing
Machine, the tape alphabet <span class="math inline">\(\Gamma  \supseteq
\Sigma\)</span> has two (rather than one) special characters <span
class="math inline">\(\scalebox{1.5}{\textvisiblespace}\)</span> and
<span class="math inline">\(\text{\lightning}\)</span>:</p>
<ul>
<li><p><span class="math inline">\(\scalebox{1.5}{\textvisiblespace}\in
\Gamma\)</span>, <span
class="math inline">\(\scalebox{1.5}{\textvisiblespace}\not\in
\Sigma\)</span>: This is the usual blank symbol.</p></li>
<li><p><span class="math inline">\(\text{\lightning}\in \Gamma\)</span>,
<span class="math inline">\(\text{\lightning}\not\in \Sigma\)</span>:
This symbol indicates a cell that has been corrupted. The machine cannot
write over any corrupted cell; that is, for each <span
class="math inline">\(q \in Q\)</span>, <span
class="math display">\[\delta(q, \text{\lightning}) \in \{ (r,
\text{\lightning}, D) \mid r \in Q, D \in \{L, R\} \}\]</span></p></li>
</ul>
<p>Computation in the corrupted Turing Machine proceeds as normal except
that sometimes when writing a tape symbol as intended, a <span
class="math inline">\(\text{\lightning}\)</span> symbol is written
instead. Thankfully, the pattern of corruption is predictable: the first
write is corrupted, and then every other write thereafter is corrupted.
That is, the first, third, fifth,... etc. writes are corrupted.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that for
every <span><strong>regular</strong></span> language <span
class="math inline">\(L\)</span>, there exists a corrupted Turing
Machine <span class="math inline">\(M\)</span> that recognizes <span
class="math inline">\(L\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) It will turn out
that the Corrupted Turing Machine is no less powerful than our usual
definition of a Turing Machine. Let’s break the proof into a few steps.
First, define the alphabet <span
class="math inline">\(\Sigma_{\mathrm{pairs}}:= \Sigma \times \Sigma =
\{ (a,b) \mid a \in \Sigma, b \in \Sigma\}\)</span> of pairs of symbols
in <span class="math inline">\(\Sigma\)</span>. Give the construction of
a Corrupted Turing Machine that takes input <span
class="math inline">\(a = a_1 a_2 \cdots a_n \in \Sigma^*\)</span> and
rewrites it as pairs of symbols interspersed by corrupted symbols. To be
precise, the Corrupted Turing Machine should take starting tape
configuration <span class="math display">\[\begin{array}{| c | c | c | c
| c | c | c | c | }  \hline
a_1 &amp; a_2 &amp; \ldots &amp; a_{n-1} &amp; a_{n} &amp;
\scalebox{1.5}{\textvisiblespace}&amp;
\scalebox{1.5}{\textvisiblespace}&amp; \ldots \\ \hline
\end{array}\]</span> to the tape configuration <span
class="math display">\[\begin{array}{| c | c | c | c | c | c | c | c | c
| c | c | c| }  \hline
\text{\lightning}&amp; (a_1, a_2) &amp; \text{\lightning}&amp; (a_3,a_4)
&amp; \text{\lightning}&amp; \ldots&amp; \text{\lightning}
&amp; (a_{n-1}, a_{n}) &amp; \text{\lightning}&amp;
\scalebox{1.5}{\textvisiblespace}&amp;
\scalebox{1.5}{\textvisiblespace}&amp; \ldots \\ \hline
\end{array}\]</span> with the head once again pointing to the first
cell. For simplicity, you may assume that <span
class="math inline">\(n\)</span> is even.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Starting from the
tape configuration we created in the previous step, describe the
implementation of a Corrupted Turing Machine which simulates the
computation of any normal/uncorrupted Turing Machine.</p>
<p><em>Challenge; not graded</em>: A key idea in the construction above
was to increase the number of symbols in our tape alphabet. Can you do
the same construction <em>without</em> increasing the size of the tape
alphabet? That is, for every language <span
class="math inline">\(L\)</span> recognized by a normal Turing machine
over alphabet <span class="math inline">\(\Sigma\)</span> and tape
alphabet <span class="math inline">\(\Sigma \cup
\{\scalebox{1.5}{\textvisiblespace}\}\)</span>, is there a Corrupted
Turing Machine with tape alphabet <span class="math inline">\(\Sigma
\cup \{\scalebox{1.5}{\textvisiblespace},\text{\lightning}\}\)</span>
that recognizes <span class="math inline">\(L\)</span>?</p></li>
</ol></li>
<li><p><strong>True/False enumerator</strong> (20 points):<br />
For each of the following statements, determine if it is true or false.
Clearly label your choice by starting your solution with
<span><strong>True</strong></span> or
<span><strong>False</strong></span> and then provide a brief (3-4
sentences or so) justification for your answer.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Every enumerator
enumerates an infinite language.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(E\)</span> be any enumerator and <span
class="math inline">\(M\)</span> be any Turing machine. If <span
class="math inline">\(L(E) = L(M)\)</span>, then <span
class="math inline">\(M\)</span> enters the reject state for all strings
not in <span class="math inline">\(L(E)\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(E\)</span> be any enumerator over <span
class="math inline">\(\Sigma\)</span>. Suppose <span
class="math inline">\(a, b \in \Sigma^*\)</span> and <span
class="math inline">\(a, b \in L(E)\)</span>. If <span
class="math inline">\(E\)</span> prints <span
class="math inline">\(a\)</span> before <span
class="math inline">\(b\)</span>, then <span class="math inline">\(|a|
\le |b|\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(M\)</span> decide language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span> such that <span
class="math inline">\(M\)</span> halts on all inputs <span
class="math inline">\(w \in \Sigma^*\)</span> in <span
class="math inline">\(|w|^{2023}\)</span> steps. There exists an
enumerator <span class="math inline">\(E\)</span> with the following
properties: <span class="math inline">\(L(E) = L(M)\)</span>; and if
<span class="math inline">\(a, b \in L\)</span> and <span
class="math inline">\(|a| &lt; |b|\)</span>, then <span
class="math inline">\(E\)</span> prints <span
class="math inline">\(a\)</span> before <span
class="math inline">\(b\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(N\)</span> be a nondeterministic Turing machine.
There is an enumerator <span class="math inline">\(E\)</span> that
enumerates the set of all and only strings accepted by <span
class="math inline">\(N\)</span> that have odd length.</p></li>
</ol></li>
</ol>
<p><strong>In this assignment:</strong> You will use general
constructions and specific machines to explore the classes of
recognizable and decidable languages. You will explore various ways to
encode machines as strings so that computational problems can be
recognized.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 6 through Week 7. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Chapter 4 exercises
4.1, 4.3, 4.4., 4.5. Chapter 4 Problems 4.29, 4.30.</p>
<p><em>Key Concepts:</em> uring-recognizable languages, Turing-decidable
languages, Church-Turing thesis, computational problems.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw6CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>Explicit encodings</strong> (8 points):<br />
In a computational problem, the elements of the language are encodings
of machines. For example, consider the language <span
class="math display">\[E_{\mathrm{DFA}} := \{ \langle M \rangle \mid M
\text{ is a DFA, and } L(M) = \varnothing \}\]</span> where each string
<span class="math inline">\(\langle M \rangle\)</span> in the language
encodes a DFA <span class="math inline">\(M = (Q, \Sigma, \delta, q_0,
F)\)</span>. Usually, we purposefully drop the details about how this
encoding is done because they can distract from the central
computational properties of the language. In fact, any encoding can be
used so long as there exists a decider for syntactic questions about the
DFAs being encoded. In this question, we will build some specific
explicit examples of encodings of DFAs to get more comfortable with
these ideas.</p>
<ol>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn10"
class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>
<em>Encoding with delimiters:</em> Perhaps the most straightforward way
to create an encoding is to have it mirror the structure of the tuple
<span class="math inline">\((Q, \Sigma, \delta, q_0, F)\)</span> for the
DFA. Your task: describe an encoding that maps each DFA <span
class="math inline">\(M\)</span> to a distinct string <span
class="math inline">\(\langle M \rangle\)</span> that uniquely
identifies <span class="math inline">\(M\)</span>. That is, if you
“decode” the encoding, you get the exact same machine back.</p>
<ul>
<li><p>You may use special characters like <span
class="math inline">\(\#\)</span> and <span
class="math inline">\(\$\)</span> as delimiters in your encoding to
separate the various components.<br />
</p></li>
<li><p>Your encoding alphabet must be finite</p></li>
</ul></li>
<li><p>(<span><em>Graded for completeness</em></span>) Use your encoding
from part (a) to produce the string encoding the DFA below:</p>
<div class="center">

</div></li>
<li><p>(<span><em>Graded for completeness</em></span>) Show that it is
possible to have the same kind of delimited encoding without using
special delimiter characters. In particular, prove that for every DFA
<span class="math inline">\(M\)</span>, we can assume that <span
class="math inline">\(\langle M \rangle \subseteq
\{0,1\}^*\)</span>.</p></li>
</ol>
<p><em>Challenge; not graded:For the delimited encoding schemes above,
there are strings over the encoding alphabet (<span
class="math inline">\(\Sigma\)</span>) that nevertheless do not
correspond to a valid DFA. Prove/disprove: There exists an encoding
scheme for which this is not true; that is, <span
class="math display">\[\{ \langle M \rangle \mid M \text{ is a DFA}\} =
\Sigma^*.\]</span></em></p></li>
<li><p><strong>Closure</strong> (18 points):<br />
Let <span class="math inline">\(\Sigma = \{0,1\}\)</span> and <span
class="math inline">\(\Gamma = \{0,1,2\}\)</span>. Recall the functions
<span class="math display">\[\begin{aligned}
    \textsc{Substring}(K) &amp;:= \{ w \in \Gamma^* \mid \text{there
exist } a,b \in \Gamma^* \text{ such that } awb \in K\} \\
    \textsc{Rep}(L) &amp;:= \{ w \in \Gamma^* \mid \text{between every
    pair of successive $2$s in $w$ is a string in $L$}\}\\
    &amp;\phantom{:}=\{w \in \Gamma^* \mid \text{for all } v \in
\Sigma^* \text{ if } 2v2 \in \textsc{Substring}(\{w\})  \text{, then } v
\in L\}
    
\end{aligned}\]</span></p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn11"
class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
Prove that, given any deterministic decider over <span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(M_L\)</span>, there is a deterministic decider
over <span class="math inline">\(\Gamma\)</span> that recognizes <span
class="math display">\[\textsc{Rep}(~L(M_L)~)\]</span> In other words,
you will prove that for any Turing-decidable language <span
class="math inline">\(L\)</span> over <span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\textsc{Rep}(L)\)</span> is also Turing-decidable.
A complete answer will include both a precise construction of the
machine and a (brief) justification of why this machine works as
required.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that, given
any nondeterministic Turing machine over <span
class="math inline">\(\Gamma\)</span>, <span
class="math inline">\(N_L\)</span>, there is a nondeterministic Turing
machine over <span class="math inline">\(\Gamma\)</span> that recognizes
<span class="math display">\[\textsc{Substring}(~L(N_L)~)\]</span> In
other words, you will prove that the class of Turing-recognizable
languages over <span class="math inline">\(\Gamma\)</span> is closed
under the <span class="math inline">\(\textsc{Substring}\)</span>
operation. A complete answer will include both a precise construction of
the machine and a (brief) justification of why this machine works as
required.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) Give a different
proof that the class of Turing-recognizable languages over <span
class="math inline">\(\Gamma\)</span> is closed under the <span
class="math inline">\(\textsc{Substring}\)</span> operation, this time
using only deterministic Turing machines. A complete answer will include
both a precise construction of the machine and a (brief) justification
of why this machine works as required.</p></li>
</ol></li>
<li><p><strong>Computational problems</strong> (24 points):<br />
For each of the following statements, determine if it is true or false.
Clearly label your choice by starting your solution with
<span><strong>True</strong></span> or
<span><strong>False</strong></span> and then provide a brief (3-4
sentences or so) justification for your answer.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) For each regular
language <span class="math inline">\(K\)</span>, the language <span
class="math display">\[\{ \langle M \rangle \mid M \text{ is a DFA and }
L(M) = K\}\]</span> is decidable.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) For each regular
language <span class="math inline">\(L\)</span>, the language <span
class="math display">\[\{ \langle M_1, M_2 \rangle \mid M_1, M_2\text{
are both DFA and }
L(M_1) \subseteq L \text{ and } L(M_2) \subseteq \overline{L}\}\]</span>
is decidable.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Let <span
class="math inline">\(\mathrm{Model} \in \{\mathrm{DFA}, \mathrm{NFA},
\mathrm{REX}, \mathrm{CFG}, \mathrm{PDA} \}\)</span>. If <span
class="math inline">\(EQ_{\mathrm{Model}}\)</span> is decidable, then
<span class="math inline">\(E_{\mathrm{Model}}\)</span> is
decidable.</p></li>
</ol>
<p><span><em>Challenge; not graded: Let <span
class="math inline">\(\mathrm{Model} \in \{\mathrm{DFA}, \mathrm{NFA},
\mathrm{REX}, \mathrm{CFG}, \mathrm{PDA} \}\)</span>. If <span
class="math inline">\(A_{\mathrm{Model}}\)</span> is decidable, then
<span class="math inline">\(EQ_{\mathrm{Model}}\)</span> is
decidable.</em></span></p></li>
</ol>
<p><strong>In this assignment:</strong> You will use general
constructions and specific machines to explore the classes of
recognizable, decidable, and undecidable languages. You will use
computable functions to relate the difficulty levels of languages via
mapping reduction.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 7 through Week 9. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Chapter 5 exercises
5.4, 5.5, 5.6, 5.7. Chapter 5 problems 5.10, 5.11, 5.16, 5.18.</p>
<p><em>Key Concepts:</em> Computational problems, diagonalization,
undecidability, unrecognizability, computable function, mapping
reduction.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw7CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>Properties of mapping reductions</strong> (20
points):<br />
In the review quizzes, we saw that mapping reductions are transitive and
are not symmetric. That is, if <span class="math inline">\(A \le_m
B\)</span> and <span class="math inline">\(B \le_m C\)</span>, then
<span class="math inline">\(A \le_m C\)</span> and there are sets <span
class="math inline">\(A, B\)</span> where <span class="math inline">\(A
\le_m B\)</span> but it is not the case that <span
class="math inline">\(B \le_m A\)</span>.</p>
<p>In this question, we’ll explore other properties of mapping
reductions. We fix the alphabet <span
class="math inline">\(\Sigma\)</span> and all sets we consider are
languages over this alphabet.</p>
<p>For each of the following statements, determine if it is true or
false. Clearly label your choice by starting your solution with
<span><strong>True</strong></span> or
<span><strong>False</strong></span> and then provide a brief (3-4
sentences or so) justification for your answer.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn12"
class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>
Mapping reductions are *not* related to subset inclusion. That is, there
are example sets <span class="math inline">\(A,B,C,D\)</span> where
<span class="math inline">\(A \subseteq B\)</span> and <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(C \not \subseteq D\)</span> and <span
class="math inline">\(C \leq_m D\)</span>. <span><em>Note: the notation
<span class="math inline">\(C \not \subseteq D\)</span> means that <span
class="math inline">\(C\)</span> is not a subset of <span
class="math inline">\(D\)</span>. That is, there is an element of <span
class="math inline">\(C\)</span> that is not an element of <span
class="math inline">\(D\)</span>.</em></span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) For every
decidable language <span class="math inline">\(L\)</span>, there is a
regular language <span class="math inline">\(R\)</span> such that <span
class="math inline">\(L \le_m R\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Mapping
reducibility is preserved under complement. That is, for all sets <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span>, if <span class="math inline">\(A \le_m
B\)</span>, then <span class="math inline">\(\overline{A} \le_m
\overline{B}\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(A \le_m B\)</span> for every decidable language
<span class="math inline">\(A\)</span> and every co-recognizable
language <span class="math inline">\(B\)</span>. <span><em>Note: the
definition of co-recognizable is from Week 8 and is: A language <span
class="math inline">\(L\)</span> over an alphabet <span
class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</em> </span></p></li>
</ol></li>
<li><p><strong>What’s wrong with these reductions?</strong> (20
points):<br />
Suppose your friends are practicing coming up with mapping reductions
<span class="math inline">\(A \leq_m B\)</span> and their witnessing
functions <span class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span>.
For each of the following attempts, determine if it is has error(s) or
is correct. Do so by labelling each attempt with all and only the labels
below that apply, and justifying this labelling.</p>
<ul>
<li><p><em>Error Type 1:</em> The given function can’t witness the
claimed mapping reduction because there exists an <span
class="math inline">\(x \in A\)</span> such that <span
class="math inline">\(f(x) \not\in B\)</span>.</p></li>
<li><p><em>Error Type 2:</em> The given function can’t witness the
claimed mapping reduction because there exists an <span
class="math inline">\(x \not\in A\)</span> such that <span
class="math inline">\(f(x) \in B\)</span>.</p></li>
<li><p><em>Error Type 3:</em> The given function can’t witness the
claimed mapping reduction because the specified function is not
computable.</p></li>
<li><p><em>Correct:</em> The claimed mapping reduction is true and is
witnessed by the given function.</p></li>
</ul>
<p>Clearly present your answer by first listing all the relevant labels
from above and then providing a brief (3-4 sentences or so)
justification for each of those labels.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(A_{\mathrm{TM}} \le_m HALT_{\mathrm{TM}}\)</span>
and <span class="math display">\[f(x) = \begin{cases}
\scalebox{.5}{$\langle$ \hspace{-.5cm} \raisebox{-.4cm}{
\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt, auto, node
distance=2cm, semithick]
  \tikzstyle{every state}=[text=black, fill=yellow!40]
  \node[initial,state,accepting]
(q0)                    {$q_{\mathrm{acc}}$};
;
\end{tikzpicture}}
$\rangle$}  
&amp; \text{if } x = \langle M, w \rangle \text{ for a Turing machine
$M$ and string $w$}\\
&amp; \qquad \qquad \text{ and } w \in L(M) \\

\scalebox{.5}{$\langle$ \hspace{-.5cm} \raisebox{-.4cm}{
\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt, auto, node
distance=2cm, semithick]
  \tikzstyle{every state}=[text=black, fill=yellow!40]
  \node[initial,state] (q0)                    {$q_0$};
  \path (q0) edge  [loop right] node {$0, 1,
\scalebox{1.5}{\textvisiblespace}\to R$} (q0)
;
\end{tikzpicture}}
$\rangle$}
&amp; \text{otherwise}
\end{cases}\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(\{w w \mid w \in \{0,1\}^* \} \le_m \{ w \mid w
\in \{0,1\}^* \}\)</span> and <span class="math display">\[f(x) =
\begin{cases}
w &amp; \text{if } x = w w \text{ for a string $w$ over $\{0,1\}$}\\
\varepsilon &amp; \text{otherwise}
\end{cases}\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(EQ_{\mathrm{TM}} \le_m A_{\mathrm{TM}}\)</span>
with <span class="math display">\[f(x) = \begin{cases}
\scalebox{.7}{$\langle$ \hspace{-.5cm} \raisebox{-.4cm}{
\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt, auto, node
distance=2cm, semithick]
  \tikzstyle{every state}=[text=black, fill=yellow!40]
  \node[initial,state,accepting]
(q0)                    {$q_{\mathrm{acc}}$};
;
\end{tikzpicture}}
, $M_w \rangle$}  &amp; \text{if } x = \langle M, w \rangle \text{ for a
Turing machine $M$ and string $w$}\\\\
\varepsilon &amp; \text{otherwise}.
\end{cases}\]</span> Where for each Turing machine <span
class="math inline">\(M\)</span>, we define <span
class="math display">\[\begin{aligned}
    M_w = ``&amp;\text{On input y} \\
    &amp;1. \text{   Simulate $M$ on $w$.}\\
    &amp;2. \text{   If it accepts, accept.}\\
    &amp;3. \text{   If it rejects, reject.&quot;}
\end{aligned}\]</span> You may assume that <span
class="math inline">\(\varepsilon\)</span> is never a valid encoding and
that encodings of pairs of Turing machines are never the same as
encodings of a Turing machine and an input string (i.e., <span
class="math inline">\(\langle M_1, M_2 \rangle \neq \langle M_3, w
\rangle\)</span>).</p></li>
</ol></li>
<li><p><strong>Computational histories</strong> (10 points):<br />
At any point in the computation of a Turing machine, we can record what
is going on by (metaphorically) taking a “snapshot”. We want this
snapshot to contain all the information needed to simulate the rest of
the computation. In particular, the snapshot encodes the</p>
<ul>
<li><p>Tape contents: Although the tape is infinite, at any specific
point in a computation, only finitely many cells have been used. These
are the only relevant tape contents to be encoded.</p></li>
<li><p>Head position: An index to which position on the tape the head is
currently pointing.</p></li>
<li><p>State: An index to which state in the finite control the
computation is currently at.</p></li>
</ul>
<p>Notice that much like the encoding <span
class="math inline">\(\langle M \rangle\)</span> of a Turing machine
<span class="math inline">\(M\)</span>, we can encode all of this
snapshot information in a single string called a <em>configuration</em>
(usually denoted by the letter <span class="math inline">\(C\)</span>).
In the same spirit of getter functions for components of encodings, all
of the relevant information can effectively be extracted from the
configuration. More formally, there is a computable function which
computes each of the tape contents, head position, and state given a
configuration as input. See Sipser Figure 3.4 (and surrounding
discussion) for an explicit example of a configuration.</p>
<p>A computational history for Turing machine <span
class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span> is sequence of configurations <span
class="math inline">\(C_1, C_2, \ldots, C_k\)</span> such that
configuration <span class="math inline">\(C_{i+1}\)</span> results from
taking one step in the Turing machine computation corresponding to <span
class="math inline">\(C_i\)</span> (in other words, one application of
the transition function). Additionally, <span
class="math inline">\(C_1\)</span> is the starting configuration,
corresponding to the tape that has the characters <span
class="math inline">\(w\)</span> on the leftmost <span
class="math inline">\(|w|\)</span>-many cells of the tape, the tape head
at the leftmost position, and the current state being the starting state
of the Turing machine. We say that a computational history is
<span><em>accepting</em></span> if the final configuration in the
sequence <span class="math inline">\(C_k\)</span> has the current state
being the accept state of the Turing machine.</p>
<p>Let’s suppose we can describe both the encodings of Turing machines
and configurations using the alphabet <span class="math inline">\(\Sigma
= \{0,1\}\)</span>. That is, <span class="math inline">\(\langle M
\rangle \in \Sigma^*\)</span> and <span class="math inline">\(C \in
\Sigma^*\)</span> for any Turing machine <span
class="math inline">\(M\)</span> and configuration of the Turing machine
<span class="math inline">\(C\)</span>. We define the language of
accepting computational histories over the alphabet <span
class="math inline">\(\Gamma = \{0,1,
2\}\)</span>: <span class="math display">\[\begin{aligned}
H:= \{ \langle M \rangle 2 \langle w \rangle 2 C_1 2 \cdots 2 C_k
\mid&amp; ~M \textrm{ is a Turing machine, $w$ is a string,} \\
&amp;C_1, \ldots, C_k \text{ is the computational history of } M \text{
on } w \\
&amp;\text{and is accepting} \}
\end{aligned}\]</span> That is, strings in the language <span
class="math inline">\(H\)</span> start with an encoding of some Turing
machine <span class="math inline">\(M\)</span>, followed by an encoding
of some string <span class="math inline">\(w\)</span>, followed by an
accepting computational history of <span
class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span>. There is a <span
class="math inline">\(2\)</span> symbol between each of these components
to serve as a delimiter. To be clear, each of these encodings is over
the alphabet <span class="math inline">\(\{0,1\}\)</span>, but you may
also assume that it’s possible to decide whether or not a particular bit
string is an encoding of a Turing machine, a configuration, or
neither.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Give a high-level
description for a Turing machine that decides <span
class="math inline">\(H\)</span> and justify why it works. Namely, prove
that the Turing machine you define halts for each input and that it
accepts an arbitrary string if and only if that string is in <span
class="math inline">\(H\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn13"
class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>
Prove that <span class="math inline">\(\textsc{Substring}(H)\)</span> is
undecidable by showing a mapping reduction from <span
class="math inline">\(A_{\mathrm{TM}}\)</span>. That is, you will prove
that <span class="math inline">\(A_{\mathrm{TM}} \le_m
\textsc{Substring}(H)\)</span> by giving a witnessing function. Recall
that for any language <span class="math inline">\(K \subseteq
\Gamma^*\)</span>, we define <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}.\]</span> Combining parts (a) and (b), notice that this implies that
the class of decidable languages is not closed under the <span
class="math inline">\(\textsc{Substring}\)</span> operation.</p></li>
</ol></li>
</ol>
<p>The project component is designed for you to go deeper and extend
your work on assignments and to explore an application of your choosing.
The project is an individual assignment and has two tasks:</p>
<ul>
<li><p>Task 1: A meaningful language (written) and</p></li>
<li><p>Task 2: A helpful function (some programming, presented as a
screencast video).</p></li>
</ul>
<h3 class="unnumbered" id="what-resources-can-you-use">What resources
can you use?</h3>
<p>This project must be completed individually, without any help from
other people, including the course staff (other than logistics support
if you get stuck with screencast).</p>
<p>You can use any of this quarter’s CSE 105 offering (notes, readings,
class videos, homework feedback). These resources should be more than
enough.</p>
<p>If you are struggling to get started and want to look elsewhere
online, you must acknowledge this by listing and citing any resources
you consult (even if you do not explicitly quote them), including any
large-language model style resources. Link directly to them and include
the name of the author / video creator, any search strings or prompts
you used, and the reason you consulted this reference.</p>
<p>The work you submit for the project needs to be your own. Again, you
shouldn’t need to look anywhere other than this quarter’s material and
doing so may result in definitions or notations that conflict with our
norms in this class so think carefully before you go down this path.</p>
<h3 class="unnumbered" id="submitting-the-project">Submitting the
project</h3>
<p>You will submit a PDF for Task 1 and a video for Task 2 to an online
assignment on Gradescope.</p>
<h2 class="unnumbered" id="task-1-a-meaningful-language">Task 1: A
meaningful language</h2>
<p>Automaton models are useful for concisely representing patterns. In
this question, you’ll choose a pattern in an application you care about,
define it precisely, and then build a DFA, NFA, or PDA that recognizes
it.</p>
<p>First, pick <span><strong>one</strong></span> application for your
example. Here are some ideas to get you started - but you can choose to
go in a different direction all together.</p>
<ul>
<li><p>Data validation for input in text files (e.g. emails with
specific domains, dates in specific formats, PIDs in a class list,
etc.)</p></li>
<li><p>Finding ASCII codes for punctuation in a binary file.</p></li>
<li><p>The CDC recommended procedure for hand washing (Refer to the
guidelines from the CDC here https://www.cdc.gov/handwashing/index.html
in your explanation. You might find the first example in chapter 1 about
automatic door controllers helpful when starting your design.)</p></li>
<li><p>See more ideas here:</p>
<p><span><a
href="https://theory-cs.github.io/files/practical-applications-of-theory-of-computation.pdf"
class="uri">https://theory-cs.github.io/files/practical-applications-of-theory-of-computation.pdf</a></span></p></li>
</ul>
<p>Then:</p>
<ol>
<li><p>In a paragraph or so, give the context for your chosen
application and why you chose it.</p></li>
<li><p>Specify the alphabet for your example.</p></li>
<li><p>Write a precise (mathematical and/or English) description of a
set of strings over this alphabet that is important, and include a
sentence or so justifying why this set is important.</p></li>
<li><p>Give one example of a string in this set and a string not in this
set, and explain why you chose these example strings.</p></li>
<li><p>Classify your language as regular or context-free, and prove this
classification by giving an appropriate machine that recognizes your
language. Justify your construction.</p></li>
</ol>
<h3 class="unnumbered" id="grading-criteria-and-checklists">Grading
criteria and checklists</h3>
<p>Solution is typed out in detail step-by-step, with clear and correct
logic and justification.</p>
<p>Each of the five items are included, with precise language and
notation for all terms and complete, correct, and clear
justification.</p>
<h2 class="unnumbered" id="task-2-a-helpful-function">Task 2: A helpful
function</h2>
<p>To relate the difficulty level of one language to another we use
mapping reduction, which relies on the notion of computable function. In
this part of the project, you will define, program, and trace a specific
computable function from <span class="math inline">\(\{a,b\}^*\)</span>
to <span class="math inline">\(\{a,b\}^*\)</span>.</p>
<p>First, choose a function you will be working with. You can pick any
function you like so long as:</p>
<ul>
<li><p>Its domain is <span class="math inline">\(\{a,b\}^*\)</span> and
its codomain is <span class="math inline">\(\{a,b\}^*\)</span></p></li>
<li><p>There is at least one domain element that is mapped to a string
that is <span><strong>longer</strong></span> than it and there is at
least one domain element that is mapped to a string that is
<span><strong>shorter</strong></span> than it.</p></li>
</ul>
<p>Then:</p>
<ol>
<li><p>Give a high-level description of a Turing machine that computes
this function.</p></li>
<li><p>Draw the state diagram of this Turing machine.</p></li>
<li><p>Write a program in Java, Python, JavaScript, or C++ (or another
programming language of your choosing) that simulates the computations
of this Turing machine. Your program should display a snapshot of each
step of the computation, including the state of the machine, the current
(non-blank) contents of the tape, and the location of the read/write
head of the Turing machine. If you would like, you may use aids such as
co-pilot or ChatGPT to help you write this program. However, you should
test the code that is produced and be able to explain what it is doing.
As a header in your code file, include a comment block describing any
resources that were used to help generate your code.</p></li>
<li><p>Run your program on a string over <span
class="math inline">\(\{a,b\}\)</span> which the function maps to a
string that is longer than it, and</p></li>
<li><p>Run your program on a string over <span
class="math inline">\(\{a,b\}\)</span> which the function maps to a
string that is shorter than it.</p></li>
</ol>
<p>Presenting your reasoning and demonstrating it via screenshare are
important skills that also show us a lot of your learning. Getting
practice with this style of presentation is a good thing for you to
learn in general and a rich way for us to assess your skills. To
demonstrate your work, you will create a 3-5 minute screencast video
with the following components:</p>
<ul>
<li><p>Start with your face and your student ID for a few seconds at the
beginning, and introduce yourself audibly while on screen. You don’t
have to be on camera for the rest of the video, though it’s fine if you
are. We are looking for a brief confirmation that it’s you creating the
video and doing the work you submitted.</p></li>
<li><p>Present the function you will be working with. Your video should
include a clear and precise definition of the function (before you
introduce any Turing machines).</p></li>
<li><p>Show on the screen and explain the high-level description of your
Turing machine witnessing that your function is computable.</p></li>
<li><p>Show on the screen and explain the state diagram of your Turing
machine.</p></li>
<li><p>Show on the screen and present your code, including the software
design choices you made (e.g. which data structures are you using, etc.)
and any resources you used.</p></li>
<li><p>Demonstrate running your code on the two example input strings
specified above. Explain why the output of your program is what you
would expect.</p></li>
</ul>
<h3 class="unnumbered" id="grading-criteria-and-checklists-1">Grading
criteria and checklists</h3>
<p>Logistics: video loads correctly, is between 3 and 5 minutes, shows
the student’s face and ID, and they introduce themself audibly while on
screen.</p>
<p>The video clearly states which function was chosen for study, the
function which is well-defined and computable, the video presents the
two different descriptions of the Turing machine clearly, and the Turing
machine correctly computes the function.</p>
<p>The video clearly describes which programming language was chosen for
the implementation and gives the reasons why.</p>
<p>The video discusses the connections between the state diagram of the
Turing machine and its implementation in the code.</p>
<p>The video clearly demonstrates all test cases, including both
expected and actual output. The video should include screencasts of
running the code live to demonstrate these test cases.</p>
<h3 class="unnumbered" id="your-video">Your video:</h3>
<p>You may produce screencasts with any software you choose. One option
is to record yourself with Zoom; a tutorial on how to use Zoom to record
a screencast (courtesy of Prof. Joe Politz) is here:</p>
<p><a
href="https://drive.google.com/open?id=1KROMAQuTCk40zwrEFotlYSJJQdcG_GUU"
class="uri">https://drive.google.com/open?id=1KROMAQuTCk40zwrEFotlYSJJQdcG_GUU</a>.</p>
<p>The video that was produced from that recording session in Zoom is
here:</p>
<p><a
href="https://drive.google.com/open?id=1MxJN6CQcXqIbOekDYMxjh7mTt1TyRVMl"
class="uri">https://drive.google.com/open?id=1MxJN6CQcXqIbOekDYMxjh7mTt1TyRVMl</a></p>
<p>Please send an email to the instructors (minnes@ucsd.edu and
dgrier@ucsd.edu) if you have concerns about the video / screencast
components of this project or cannot complete projects in this style for
some reason.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref10"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref12" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref13"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
</body>
</html>
