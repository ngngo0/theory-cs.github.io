<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE105Sp23" />
  <title>HW7 : Undecidability, Co-Recognizability, and Mapping Reductions</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW7 : Undecidability, Co-Recognizability, and Mapping
Reductions</h1>
<p class="author">CSE105Sp23</p>
<p class="date">Due: June 6th at 5pm (no penalty late submission until
8am next morning), via Gradescope</p>
</header>
<p><strong>In this assignment:</strong> You will use general
constructions and specific machines to explore the classes of
recognizable, decidable, and undecidable languages. You will use
computable functions to relate the difficulty levels of languages via
mapping reduction.</p>
<p><em>Resources</em>: To review the topics you are working with for
this assignment, see the class material from Week 7 through Week 9. We
will post frequently asked questions and our answers to them in a pinned
Piazza post.</p>
<p><em>Reading and extra practice problems</em>: Chapter 5 exercises
5.4, 5.5, 5.6, 5.7. Chapter 5 problems 5.10, 5.11, 5.16, 5.18.</p>
<p><em>Key Concepts:</em> Computational problems, diagonalization,
undecidability, unrecognizability, computable function, mapping
reduction.</p>
<p><span><strong>For all HW assignments:</strong></span> Weekly homework
may be done individually or in groups of up to 3 students. You may
switch HW partners for different HW assignments. The lowest HW score
will not be included in your overall HW average. Please ensure your
name(s) and PID(s) are clearly visible on the first page of your
homework submission and then upload the PDF to Gradescope. If working in
a group, submit only one submission per group: one partner uploads the
submission through their Gradescope account and then adds the other
group member(s) to the Gradescope submission by selecting their name(s)
in the “Add Group Members" dialog box. You will need to re-add your
group member(s) every time you resubmit a new version of your
assignment. Each homework question will be graded either for correctness
(including clear and precise explanations and justifications of all
answers) or fair effort completeness. You may only collaborate on HW
with CSE 105 students in your group; if your group has questions about a
HW problem, you may ask in drop-in help hours or post a private post
(visible only to the Instructors) on Piazza.</p>
<p>All submitted homework for this class must be typed. You can use a
word processing editor if you like (Microsoft Word, Open Office,
Notepad, Vim, Google Docs, etc.) but you might find it useful to take
this opportunity to learn LaTeX. LaTeX is a markup language used widely
in computer science and mathematics. The homework assignments are typed
using LaTeX and you can use the source files as templates for
typesetting your solutions. To generate state diagrams of machines, we
recommend using Flap.js or JFLAP. Photographs of clearly hand-drawn
diagrams may also be used. We recommend that you submit early drafts to
Gradescope so that in case of any technical difficulties, at least some
of your work is present. You may update your submission as many times as
you’d like up to the deadline.</p>
<p><span><strong>Integrity reminders</strong></span></p>
<ul>
<li><p>Problems should be solved together, not divided up between the
partners. The homework is designed to give you practice with the main
concepts and techniques of the course, while getting to know and learn
from your classmates.</p></li>
<li><p>You may not collaborate on homework with anyone other than your
group members. You may ask questions about the homework in office hours
(of the instructor, TAs, and/or tutors) and on Piazza (as private notes
viewable only to the Instructors). You <em>cannot</em> use any online
resources about the course content other than the class material from
this quarter – this is primarily to ensure that we all use consistent
notation and definitions (aligned with the textbook) and also to protect
the learning experience you will have when the ‘aha’ moments of solving
the problem authentically happen.</p></li>
<li><p>Do not share written solutions or partial solutions for homework
with other students in the class who are not in your group. Doing so
would dilute their learning experience and detract from their success in
the class.</p></li>
</ul>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw7CSE105Sp23”.</p>
<p><strong>Assigned questions</strong></p>
<ol>
<li><p><strong>Properties of mapping reductions</strong> (20
points):<br />
In the review quizzes, we saw that mapping reductions are transitive and
are not symmetric. That is, if <span class="math inline">\(A \le_m
B\)</span> and <span class="math inline">\(B \le_m C\)</span>, then
<span class="math inline">\(A \le_m C\)</span> and there are sets <span
class="math inline">\(A, B\)</span> where <span class="math inline">\(A
\le_m B\)</span> but it is not the case that <span
class="math inline">\(B \le_m A\)</span>.</p>
<p>In this question, we’ll explore other properties of mapping
reductions. We fix the alphabet <span
class="math inline">\(\Sigma\)</span> and all sets we consider are
languages over this alphabet.</p>
<p>For each of the following statements, determine if it is true or
false. Clearly label your choice by starting your solution with
<span><strong>True</strong></span> or
<span><strong>False</strong></span> and then provide a brief (3-4
sentences or so) justification for your answer.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
Mapping reductions are *not* related to subset inclusion. That is, there
are example sets <span class="math inline">\(A,B,C,D\)</span> where
<span class="math inline">\(A \subseteq B\)</span> and <span
class="math inline">\(A \leq_m B\)</span> and <span
class="math inline">\(C \not \subseteq D\)</span> and <span
class="math inline">\(C \leq_m D\)</span>. <span><em>Note: the notation
<span class="math inline">\(C \not \subseteq D\)</span> means that <span
class="math inline">\(C\)</span> is not a subset of <span
class="math inline">\(D\)</span>. That is, there is an element of <span
class="math inline">\(C\)</span> that is not an element of <span
class="math inline">\(D\)</span>.</em></span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) For every
decidable language <span class="math inline">\(L\)</span>, there is a
regular language <span class="math inline">\(R\)</span> such that <span
class="math inline">\(L \le_m R\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Mapping
reducibility is preserved under complement. That is, for all sets <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span>, if <span class="math inline">\(A \le_m
B\)</span>, then <span class="math inline">\(\overline{A} \le_m
\overline{B}\)</span>.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(A \le_m B\)</span> for every decidable language
<span class="math inline">\(A\)</span> and every co-recognizable
language <span class="math inline">\(B\)</span>. <span><em>Note: the
definition of co-recognizable is from Week 8 and is: A language <span
class="math inline">\(L\)</span> over an alphabet <span
class="math inline">\(\Sigma\)</span> is called
<span><strong>co-recognizable</strong></span> if its complement, defined
as <span class="math inline">\(\Sigma^* \setminus L  = \{
x  \in  \Sigma^* \mid x \notin  L \}\)</span>, is
Turing-recognizable.</em> </span></p></li>
</ol></li>
<li><p><strong>What’s wrong with these reductions?</strong> (20
points):<br />
Suppose your friends are practicing coming up with mapping reductions
<span class="math inline">\(A \leq_m B\)</span> and their witnessing
functions <span class="math inline">\(f: \Sigma^* \to \Sigma^*\)</span>.
For each of the following attempts, determine if it is has error(s) or
is correct. Do so by labelling each attempt with all and only the labels
below that apply, and justifying this labelling.</p>
<ul>
<li><p><em>Error Type 1:</em> The given function can’t witness the
claimed mapping reduction because there exists an <span
class="math inline">\(x \in A\)</span> such that <span
class="math inline">\(f(x) \not\in B\)</span>.</p></li>
<li><p><em>Error Type 2:</em> The given function can’t witness the
claimed mapping reduction because there exists an <span
class="math inline">\(x \not\in A\)</span> such that <span
class="math inline">\(f(x) \in B\)</span>.</p></li>
<li><p><em>Error Type 3:</em> The given function can’t witness the
claimed mapping reduction because the specified function is not
computable.</p></li>
<li><p><em>Correct:</em> The claimed mapping reduction is true and is
witnessed by the given function.</p></li>
</ul>
<p>Clearly present your answer by first listing all the relevant labels
from above and then providing a brief (3-4 sentences or so)
justification for each of those labels.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(A_{\mathrm{TM}} \le_m HALT_{\mathrm{TM}}\)</span>
and <span class="math display">\[f(x) = \begin{cases}
\scalebox{.5}{$\langle$ \hspace{-.5cm} \raisebox{-.4cm}{
\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt, auto, node
distance=2cm, semithick]
  \tikzstyle{every state}=[text=black, fill=yellow!40]
  \node[initial,state,accepting]
(q0)                    {$q_{\mathrm{acc}}$};
;
\end{tikzpicture}}
$\rangle$}  
&amp; \text{if } x = \langle M, w \rangle \text{ for a Turing machine
$M$ and string $w$}\\
&amp; \qquad \qquad \text{ and } w \in L(M) \\

\scalebox{.5}{$\langle$ \hspace{-.5cm} \raisebox{-.4cm}{
\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt, auto, node
distance=2cm, semithick]
  \tikzstyle{every state}=[text=black, fill=yellow!40]
  \node[initial,state] (q0)                    {$q_0$};
  \path (q0) edge  [loop right] node {$0, 1,
\scalebox{1.5}{\textvisiblespace}\to R$} (q0)
;
\end{tikzpicture}}
$\rangle$}
&amp; \text{otherwise}
\end{cases}\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(\{w w \mid w \in \{0,1\}^* \} \le_m \{ w \mid w
\in \{0,1\}^* \}\)</span> and <span class="math display">\[f(x) =
\begin{cases}
w &amp; \text{if } x = w w \text{ for a string $w$ over $\{0,1\}$}\\
\varepsilon &amp; \text{otherwise}
\end{cases}\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) <span
class="math inline">\(EQ_{\mathrm{TM}} \le_m A_{\mathrm{TM}}\)</span>
with <span class="math display">\[f(x) = \begin{cases}
\scalebox{.7}{$\langle$ \hspace{-.5cm} \raisebox{-.4cm}{
\begin{tikzpicture}[-&gt;,&gt;=stealth&#39;,shorten &gt;=1pt, auto, node
distance=2cm, semithick]
  \tikzstyle{every state}=[text=black, fill=yellow!40]
  \node[initial,state,accepting]
(q0)                    {$q_{\mathrm{acc}}$};
;
\end{tikzpicture}}
, $M_w \rangle$}  &amp; \text{if } x = \langle M, w \rangle \text{ for a
Turing machine $M$ and string $w$}\\\\
\varepsilon &amp; \text{otherwise}.
\end{cases}\]</span> Where for each Turing machine <span
class="math inline">\(M\)</span>, we define <span
class="math display">\[\begin{aligned}
    M_w = ``&amp;\text{On input y} \\
    &amp;1. \text{   Simulate $M$ on $w$.}\\
    &amp;2. \text{   If it accepts, accept.}\\
    &amp;3. \text{   If it rejects, reject.&quot;}
\end{aligned}\]</span> You may assume that <span
class="math inline">\(\varepsilon\)</span> is never a valid encoding and
that encodings of pairs of Turing machines are never the same as
encodings of a Turing machine and an input string (i.e., <span
class="math inline">\(\langle M_1, M_2 \rangle \neq \langle M_3, w
\rangle\)</span>).</p></li>
</ol></li>
<li><p><strong>Computational histories</strong> (10 points):<br />
At any point in the computation of a Turing machine, we can record what
is going on by (metaphorically) taking a “snapshot”. We want this
snapshot to contain all the information needed to simulate the rest of
the computation. In particular, the snapshot encodes the</p>
<ul>
<li><p>Tape contents: Although the tape is infinite, at any specific
point in a computation, only finitely many cells have been used. These
are the only relevant tape contents to be encoded.</p></li>
<li><p>Head position: An index to which position on the tape the head is
currently pointing.</p></li>
<li><p>State: An index to which state in the finite control the
computation is currently at.</p></li>
</ul>
<p>Notice that much like the encoding <span
class="math inline">\(\langle M \rangle\)</span> of a Turing machine
<span class="math inline">\(M\)</span>, we can encode all of this
snapshot information in a single string called a <em>configuration</em>
(usually denoted by the letter <span class="math inline">\(C\)</span>).
In the same spirit of getter functions for components of encodings, all
of the relevant information can effectively be extracted from the
configuration. More formally, there is a computable function which
computes each of the tape contents, head position, and state given a
configuration as input. See Sipser Figure 3.4 (and surrounding
discussion) for an explicit example of a configuration.</p>
<p>A computational history for Turing machine <span
class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span> is sequence of configurations <span
class="math inline">\(C_1, C_2, \ldots, C_k\)</span> such that
configuration <span class="math inline">\(C_{i+1}\)</span> results from
taking one step in the Turing machine computation corresponding to <span
class="math inline">\(C_i\)</span> (in other words, one application of
the transition function). Additionally, <span
class="math inline">\(C_1\)</span> is the starting configuration,
corresponding to the tape that has the characters <span
class="math inline">\(w\)</span> on the leftmost <span
class="math inline">\(|w|\)</span>-many cells of the tape, the tape head
at the leftmost position, and the current state being the starting state
of the Turing machine. We say that a computational history is
<span><em>accepting</em></span> if the final configuration in the
sequence <span class="math inline">\(C_k\)</span> has the current state
being the accept state of the Turing machine.</p>
<p>Let’s suppose we can describe both the encodings of Turing machines
and configurations using the alphabet <span class="math inline">\(\Sigma
= \{0,1\}\)</span>. That is, <span class="math inline">\(\langle M
\rangle \in \Sigma^*\)</span> and <span class="math inline">\(C \in
\Sigma^*\)</span> for any Turing machine <span
class="math inline">\(M\)</span> and configuration of the Turing machine
<span class="math inline">\(C\)</span>. We define the language of
accepting computational histories over the alphabet <span
class="math inline">\(\Gamma = \{0,1,
2\}\)</span>: <span class="math display">\[\begin{aligned}
H:= \{ \langle M \rangle 2 \langle w \rangle 2 C_1 2 \cdots 2 C_k
\mid&amp; ~M \textrm{ is a Turing machine, $w$ is a string,} \\
&amp;C_1, \ldots, C_k \text{ is the computational history of } M \text{
on } w \\
&amp;\text{and is accepting} \}
\end{aligned}\]</span> That is, strings in the language <span
class="math inline">\(H\)</span> start with an encoding of some Turing
machine <span class="math inline">\(M\)</span>, followed by an encoding
of some string <span class="math inline">\(w\)</span>, followed by an
accepting computational history of <span
class="math inline">\(M\)</span> on input <span
class="math inline">\(w\)</span>. There is a <span
class="math inline">\(2\)</span> symbol between each of these components
to serve as a delimiter. To be clear, each of these encodings is over
the alphabet <span class="math inline">\(\{0,1\}\)</span>, but you may
also assume that it’s possible to decide whether or not a particular bit
string is an encoding of a Turing machine, a configuration, or
neither.</p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Give a high-level
description for a Turing machine that decides <span
class="math inline">\(H\)</span> and justify why it works. Namely, prove
that the Turing machine you define halts for each input and that it
accepts an arbitrary string if and only if that string is in <span
class="math inline">\(H\)</span>.</p></li>
<li><p>(<span><em>Graded for completeness</em></span>) <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
Prove that <span class="math inline">\(\textsc{Substring}(H)\)</span> is
undecidable by showing a mapping reduction from <span
class="math inline">\(A_{\mathrm{TM}}\)</span>. That is, you will prove
that <span class="math inline">\(A_{\mathrm{TM}} \le_m
\textsc{Substring}(H)\)</span> by giving a witnessing function. Recall
that for any language <span class="math inline">\(K \subseteq
\Gamma^*\)</span>, we define <span
class="math display">\[\textsc{Substring}(K) := \{ w \in \Gamma^* \mid
\text{there exist } a,b \in \Gamma^* \text{ such that } awb \in
K\}.\]</span> Combining parts (a) and (b), notice that this implies that
the class of decidable languages is not closed under the <span
class="math inline">\(\textsc{Substring}\)</span> operation.</p></li>
</ol></li>
</ol>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This means your solution will be evaluated not only on
the correctness of your answers, but on your ability to present your
ideas clearly and logically. You should explain how you arrived at your
conclusions, using mathematically sound reasoning. Whether you use
formal proof techniques or write a more informal argument for why
something is true, your answers should always be well-supported. Your
goal should be to convince the reader that your results and methods are
sound.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This means you will get full credit so long as your
submission demonstrates honest effort to answer the question. You will
not be penalized for incorrect answers. To demonstrate your honest
effort in answering the question, we ask that you include your attempt
to answer *each* part of the question. If you get stuck with your
attempt, you can still demonstrate your effort by explaining where you
got stuck and what you did to try to get unstuck.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
</body>
</html>
